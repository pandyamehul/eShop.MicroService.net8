# CSharp.eShop.MicroService.net8

- [CSharp.eShop.MicroService.net8](#csharpeshopmicroservicenet8)
  - [Section 01 to 05: Develop Catalog.API with Vertical slice architecture and CQRS](#section-01-to-05-develop-catalogapi-with-vertical-slice-architecture-and-cqrs)
    - [49: Implement CQRS abstractions Icommand into  vertical slice feature handler class](#49-implement-cqrs-abstractions-icommand-into--vertical-slice-feature-handler-class)
    - [50: Develop Create Product endpoint with minimal API and Cater](#50-develop-create-product-endpoint-with-minimal-api-and-cater)
    - [51,52: Develop POST endpoint with Carter implements ICarterModule with minimal API](#5152-develop-post-endpoint-with-carter-implements-icartermodule-with-minimal-api)
    - [53: Register MediatR, Carter and Mapster libraries to ASP.net dependency injection services](#53-register-mediatr-carter-and-mapster-libraries-to-aspnet-dependency-injection-services)
    - [54: Test catalog API - CreateProduct POST request - Debug Carter and MediatR libraries](#54-test-catalog-api---createproduct-post-request---debug-carter-and-mediatr-libraries)
  - [Section 6: Develop Catalog.API Infrastructure, Handler and Endpoint Classes for CRUD](#section-6-develop-catalogapi-infrastructure-handler-and-endpoint-classes-for-crud)
    - [55: Introduction - Develop Catalog.API Infrastructure, Handler and Endpoint Classes](#55-introduction---develop-catalogapi-infrastructure-handler-and-endpoint-classes)
    - [56: Infrastructure - Data concerms for Catalog API - Marten .NET Transactional Db](#56-infrastructure---data-concerms-for-catalog-api---marten-net-transactional-db)
    - [57: Opening sessions in Marten as Document Db](#57-opening-sessions-in-marten-as-document-db)
    - [58: Develop Command Handler to save product to Document Db using Marten library](#58-develop-command-handler-to-save-product-to-document-db-using-marten-library)
    - [59: Register and configure Marten Document Db library into program.cs asp.net DI](#59-register-and-configure-marten-document-db-library-into-programcs-aspnet-di)
    - [60: EShops microservice - Deployment Strategy](#60-eshops-microservice---deployment-strategy)
    - [61: Setup PostgresSQL Db using Docker-compose file for Multi-container Docker Env](#61-setup-postgressql-db-using-docker-compose-file-for-multi-container-docker-env)
    - [62: Add PostgresSQL into Docker compose file for multi container docker environment](#62-add-postgressql-into-docker-compose-file-for-multi-container-docker-environment)
    - [63: Run docker compose on visual studio to setup PostgreSQL DB on docker](#63-run-docker-compose-on-visual-studio-to-setup-postgresql-db-on-docker)
    - [64: Connect Postgres Db from local catalog microservice \& send POST request](#64-connect-postgres-db-from-local-catalog-microservice--send-post-request)
    - [65: Develop GetProduct Feature in Vertical Slice Architecture with CQRS, MediatR in Handler class](#65-develop-getproduct-feature-in-vertical-slice-architecture-with-cqrs-mediatr-in-handler-class)
    - [66: Develop GET GetEndpoint with minimal API and Carter](#66-develop-get-getendpoint-with-minimal-api-and-carter)
    - [67: Test GET Product endpoint connecting to Docker Postgres Container](#67-test-get-product-endpoint-connecting-to-docker-postgres-container)
    - [68: Create API Client collection for EShop](#68-create-api-client-collection-for-eshop)
    - [69: Develop GetProductById handler with CQRS \& MediatR](#69-develop-getproductbyid-handler-with-cqrs--mediatr)
    - [70: Develop GetProductById GET endpoint with minimal API and Carter](#70-develop-getproductbyid-get-endpoint-with-minimal-api-and-carter)
    - [71: Test GetProductById endpoint connecting to Docker postgres container](#71-test-getproductbyid-endpoint-connecting-to-docker-postgres-container)
    - [72: Develop GetProductByCategory handler using CQRS and MediatR](#72-develop-getproductbycategory-handler-using-cqrs-and-mediatr)
    - [73: Develop GetProductByCategory GET endpoint with minimal API and Carter](#73-develop-getproductbycategory-get-endpoint-with-minimal-api-and-carter)
    - [74: Test GetProductByCategory endpoint connecting to Docker postgres container](#74-test-getproductbycategory-endpoint-connecting-to-docker-postgres-container)
    - [75: Develop UpdateProduct handler using CQRS and MediatR](#75-develop-updateproduct-handler-using-cqrs-and-mediatr)
    - [76: Develop UpdateProduct PUT endpoint with minimal API and Carter](#76-develop-updateproduct-put-endpoint-with-minimal-api-and-carter)
    - [77: Test UpdateProduct endpoint connecting to Docker postgres container](#77-test-updateproduct-endpoint-connecting-to-docker-postgres-container)
    - [78: Develop DeleteProduct handler using CQRS and MediatR](#78-develop-deleteproduct-handler-using-cqrs-and-mediatr)
    - [79: Develop DeleteProduct PUT endpoint with minimal API and Carter](#79-develop-deleteproduct-put-endpoint-with-minimal-api-and-carter)
    - [80: Test DeleteProduct endpoint connecting to Docker postgres container](#80-test-deleteproduct-endpoint-connecting-to-docker-postgres-container)
  - [Section 7: Develop Catalog.API Cross-cutting concerns](#section-7-develop-catalogapi-cross-cutting-concerns)
    - [81: Introduction - Develop Catalog.API Cross-cutting concerns](#81-introduction---develop-catalogapi-cross-cutting-concerns)
    - [82: MeditR pipeline behaviours \& Fluent validation library](#82-meditr-pipeline-behaviours--fluent-validation-library)
    - [83: Add cross cutting concerns into Building blocks class library for all projects](#83-add-cross-cutting-concerns-into-building-blocks-class-library-for-all-projects)
    - [84: Cross cuttig concerns - validation with abstractvalidator using Fluent validation](#84-cross-cuttig-concerns---validation-with-abstractvalidator-using-fluent-validation)
    - [85: Validation pipeline behavioud with MediatR using Fluent validation library](#85-validation-pipeline-behavioud-with-mediatr-using-fluent-validation-library)
    - [86: Remove Manual Validation and Test validation behaviour pipeline with MediatR](#86-remove-manual-validation-and-test-validation-behaviour-pipeline-with-mediatr)
    - [87: Develop CRUD Command Validation with Fluent validation pipeline behaviour](#87-develop-crud-command-validation-with-fluent-validation-pipeline-behaviour)
    - [88: Global Exception Handling in ASP.Net Core with app.UseExceptionHandler](#88-global-exception-handling-in-aspnet-core-with-appuseexceptionhandler)
    - [89: BuildingBlocks Handling Exceptions Generic way w/ app.UseExceptionHandler](#89-buildingblocks-handling-exceptions-generic-way-w-appuseexceptionhandler)
    - [90: Global Exception Handling with IExceptionHandler interface in Asp.net Core](#90-global-exception-handling-with-iexceptionhandler-interface-in-aspnet-core)
    - [91: Register Custom Exception Handling into Asp.net with AddExceptionHandler method](#91-register-custom-exception-handling-into-aspnet-with-addexceptionhandler-method)
    - [92: Logging Behavior in MediatR Pipeline for Cross-cutting concerns](#92-logging-behavior-in-mediatr-pipeline-for-cross-cutting-concerns)
    - [93: Test Logging Behaviour for all MediatR Requests on Catalog.API microservices](#93-test-logging-behaviour-for-all-mediatr-requests-on-catalogapi-microservices)
    - [94: Seeding CatalogDb with Marten Initial Baseline Data (IInitialData interface)](#94-seeding-catalogdb-with-marten-initial-baseline-data-iinitialdata-interface)
    - [95: Test Seeding Initial Data with Marten on PostgresDB for Catalog.API microservice](#95-test-seeding-initial-data-with-marten-on-postgresdb-for-catalogapi-microservice)
    - [96: Develop Pagination for GetProducts Query with ToPagedListAsync extention method](#96-develop-pagination-for-getproducts-query-with-topagedlistasync-extention-method)
    - [97: Test Pagination for GetProducts Query with ToPagedListAsync extention method](#97-test-pagination-for-getproducts-query-with-topagedlistasync-extention-method)
    - [98: Health Check for Catalog Microservices with PostgresDB](#98-health-check-for-catalog-microservices-with-postgresdb)
    - [99: Containerize Catalog.API microservices with Docker](#99-containerize-catalogapi-microservices-with-docker)
    - [100: Orchestrate Catalog.API microservices with Docker-compose file](#100-orchestrate-catalogapi-microservices-with-docker-compose-file)
    - [101: TEST - Docker-compose Catalog.API microservices with PostgresDB](#101-test---docker-compose-catalogapi-microservices-with-postgresdb)
  - [Section 8: Basket Microservices with Vertical Slice Architecture and CQRS](#section-8-basket-microservices-with-vertical-slice-architecture-and-cqrs)
    - [102: Introduction - Basket Microservices with Vertical Slice Architecture and CQRS](#102-introduction---basket-microservices-with-vertical-slice-architecture-and-cqrs)
    - [103: Create Asp.Net Web API for Basket.API Microservice in Microservices Solution](#103-create-aspnet-web-api-for-basketapi-microservice-in-microservices-solution)
    - [104: Set Port Numbers for Basket.API Microservice - Modify Launch Settings](#104-set-port-numbers-for-basketapi-microservice---modify-launch-settings)
    - [105: Domain Analysis of Basket Microservices: Models, UCs, Rest Apis, Databases](#105-domain-analysis-of-basket-microservices-models-ucs-rest-apis-databases)
    - [106: Technical Analysis of Basket Microservices: Architectures, Patterns, Libraries](#106-technical-analysis-of-basket-microservices-architectures-patterns-libraries)
    - [107: Develop Basket.API Microservices Creating Domain Entities](#107-develop-basketapi-microservices-creating-domain-entities)
    - [108: Develop Vertical Slice Feature Folder with CQRS and MediatR](#108-develop-vertical-slice-feature-folder-with-cqrs-and-mediatr)
    - [109: Develop GetBasket Feature Handler class with CQRS and MediatR](#109-develop-getbasket-feature-handler-class-with-cqrs-and-mediatr)
    - [110: Develop Get Basket Endpoint with Minimal Apis and Carte](#110-develop-get-basket-endpoint-with-minimal-apis-and-carte)
    - [111: Develop StoreBasket Feature Handler class with CQRS and MediatR](#111-develop-storebasket-feature-handler-class-with-cqrs-and-mediatr)
    - [112: Develop Store Basket Endpoint with Minimal Apis and Carter](#112-develop-store-basket-endpoint-with-minimal-apis-and-carter)
    - [113: Develop DeleteBasket Feature Handler class with CQRS and MediatR](#113-develop-deletebasket-feature-handler-class-with-cqrs-and-mediatr)
    - [114: Develop Delete Basket Endpoint with Minimal Apis and Carter](#114-develop-delete-basket-endpoint-with-minimal-apis-and-carter)
    - [115: Register MediatR and Carter libraries into Asp.Net Dependency Injection Service](#115-register-mediatr-and-carter-libraries-into-aspnet-dependency-injection-service)
    - [116: Test Basket API - GET and POST Basket Request - Debug Carter Minimal API](#116-test-basket-api---get-and-post-basket-request---debug-carter-minimal-api)
    - [117: Infrastructure - Data Concerns for Basket API - Marten .NET Transactional DB](#117-infrastructure---data-concerns-for-basket-api---marten-net-transactional-db)
    - [118: Develop BasketRepository Class using Marten Library](#118-develop-basketrepository-class-using-marten-library)
    - [119: Implement IBasketRepository Class using Marten IDocumentSession interface](#119-implement-ibasketrepository-class-using-marten-idocumentsession-interface)
    - [120: Register and Configure Marten DocumentDB library into Program.cs asp.net DI](#120-register-and-configure-marten-documentdb-library-into-programcs-aspnet-di)
    - [121: Setup PostgreSQL DB for Basket ms using Docker-compose file for Multi-container](#121-setup-postgresql-db-for-basket-ms-using-docker-compose-file-for-multi-container)
    - [122: Run Docker-Compose on Visual Studio to setup PostgreSQL DB on Docker](#122-run-docker-compose-on-visual-studio-to-setup-postgresql-db-on-docker)
    - [123: Develop Basket Features in CQRS Handler classes using BasketRepository](#123-develop-basket-features-in-cqrs-handler-classes-using-basketrepository)
    - [124: Connect Postgres DB from local Basket Microservices and send POST request](#124-connect-postgres-db-from-local-basket-microservices-and-send-post-request)
    - [125: TEST Basket Microservices Endpoints connecting with Marten and Postgres DB](#125-test-basket-microservices-endpoints-connecting-with-marten-and-postgres-db)
    - [126: Exception Handling in Basket Microservices](#126-exception-handling-in-basket-microservices)
  - [Section 9: Baskeet Microservices apply Distributed Caching with Redis](#section-9-baskeet-microservices-apply-distributed-caching-with-redis)
    - [127: Distributed Caching with Redis in Basket Microservices](#127-distributed-caching-with-redis-in-basket-microservices)
    - [128: Cache-aside Pattern in Microservices / Cache Invalidation](#128-cache-aside-pattern-in-microservices--cache-invalidation)
    - [129: Proxy Pattern, Decorator Pattern and Scrutor Library](#129-proxy-pattern-decorator-pattern-and-scrutor-library)
    - [130: Develop CachedBasketRepository with Proxy Pattern, Decorator Pattern and Scrutor](#130-develop-cachedbasketrepository-with-proxy-pattern-decorator-pattern-and-scrutor)
    - [131: Develop CachedBasketRepository with Proxy Pattern, Decorator Pattern and Scrutor](#131-develop-cachedbasketrepository-with-proxy-pattern-decorator-pattern-and-scrutor)
    - [132: Register Decorated CachedBasketRepository and StackExchangeRedis with Scrutor](#132-register-decorated-cachedbasketrepository-and-stackexchangeredis-with-scrutor)
    - [133: ECommerce Microservices Deployment Strategy](#133-ecommerce-microservices-deployment-strategy)
    - [134: Setup Redis as a Distributed Cache using Docker-compose file for Multi-container](#134-setup-redis-as-a-distributed-cache-using-docker-compose-file-for-multi-container)
    - [135: Run Docker-Compose on Visual Studio to setup Redis Distributed Cache on Docker](#135-run-docker-compose-on-visual-studio-to-setup-redis-distributed-cache-on-docker)
    - [136: Configure docker-compose launch settings - Not open browser for microservices](#136-configure-docker-compose-launch-settings---not-open-browser-for-microservices)
    - [137: Connect Redis Cache from local Basket Microservices and send GET request](#137-connect-redis-cache-from-local-basket-microservices-and-send-get-request)
    - [138: Health Check for Basket Microservices with PostgresDB and Redis Cache](#138-health-check-for-basket-microservices-with-postgresdb-and-redis-cache)
    - [139: Containerize Basket.API Microservices with Docker](#139-containerize-basketapi-microservices-with-docker)
    - [140: Orchestrate Basket.API Microservices with Docker-compose file](#140-orchestrate-basketapi-microservices-with-docker-compose-file)
    - [141: TEST - Docker-compose Basket.API microservices with PostgresDB and Redis](#141-test---docker-compose-basketapi-microservices-with-postgresdb-and-redis)
  - [Section 10: Microservices synchronous communication with gRPC (8 min)](#section-10-microservices-synchronous-communication-with-grpc-8-min)
    - [142: Microservices Communication Types: Synchronous or Asynchronous Communication](#142-microservices-communication-types-synchronous-or-asynchronous-communication)
    - [143: Microservices Synchronous Communications and Best Practices](#143-microservices-synchronous-communications-and-best-practices)
    - [144: gRPC: High Performance Remote Procedure Calls](#144-grpc-high-performance-remote-procedure-calls)
    - [145: How gRPC works ?](#145-how-grpc-works-)
    - [146: gRPC Usage in Microservices Communication](#146-grpc-usage-in-microservices-communication)
  - [Section 11: Discount.gRPC Microservices for other Microservices gRPC communication (1 hr 28 min)](#section-11-discountgrpc-microservices-for-other-microservices-grpc-communication-1-hr-28-min)
    - [Objective](#objective)
    - [147: Introduction - Discount.Grpc Microservices for Microservices Grpc Communication](#147-introduction---discountgrpc-microservices-for-microservices-grpc-communication)
    - [148: Create Asp.Net Grpc for Discount Microservices in Microservices Solution](#148-create-aspnet-grpc-for-discount-microservices-in-microservices-solution)
    - [149: Domain Analysis of Discount Microservices: Models, UCs, Rest Apis, Databases](#149-domain-analysis-of-discount-microservices-models-ucs-rest-apis-databases)
    - [150 : Technical Analysis of Discount Microservices: Architectures, Patterns, Libraries](#150--technical-analysis-of-discount-microservices-architectures-patterns-libraries)
    - [151: Develop Discount.API Microservices Creating Domain Entities](#151-develop-discountapi-microservices-creating-domain-entities)
    - [152: Develop discount.proto ProtoBuf file for Exposing Crud Services in Discount Grpc](#152-develop-discountproto-protobuf-file-for-exposing-crud-services-in-discount-grpc)
    - [153: Generate Proto Service Class from Discount proto File in Discount Grpc service](#153-generate-proto-service-class-from-discount-proto-file-in-discount-grpc-service)
    - [154: Develop DiscountService class to Implement Grpc Proto Service Methods](#154-develop-discountservice-class-to-implement-grpc-proto-service-methods)
    - [155: Configure DiscountGrpc Service to Request Pipeline in Program.cs and Invoke Grpc](#155-configure-discountgrpc-service-to-request-pipeline-in-programcs-and-invoke-grpc)
    - [156: Entity Framework Core and SQLite Database Connection in Discount Microservices](#156-entity-framework-core-and-sqlite-database-connection-in-discount-microservices)
    - [157: Create SQLite Database using Entity Framework Core Tools in Discount service](#157-create-sqlite-database-using-entity-framework-core-tools-in-discount-service)
    - [158: Seed and Auto-Migrate SQLite Database using Entity Framework Core in Discount](#158-seed-and-auto-migrate-sqlite-database-using-entity-framework-core-in-discount)
    - [159: TEST - Seed and Auto-Migrate SQLite Database using Entity Framework Core](#159-test---seed-and-auto-migrate-sqlite-database-using-entity-framework-core)
    - [160: Develop DiscountService class to Implement Grpc Proto Service Methods](#160-develop-discountservice-class-to-implement-grpc-proto-service-methods)
    - [161: Develop CreateDiscount in DiscountService class to Implement CRUD Grpc Proto](#161-develop-creatediscount-in-discountservice-class-to-implement-crud-grpc-proto)
    - [162: Develop UpdateDiscount in DiscountService class to Implement CRUD Grpc Proto](#162-develop-updatediscount-in-discountservice-class-to-implement-crud-grpc-proto)
    - [163: Develop DeleteDiscount in DiscountService class to Implement CRUD Grpc Proto](#163-develop-deletediscount-in-discountservice-class-to-implement-crud-grpc-proto)
    - [164: Containerize Discount.Grpc microservices with Docker](#164-containerize-discountgrpc-microservices-with-docker)
    - [165: Orchestrate Discount.Grpc microservices with Docker-compose file](#165-orchestrate-discountgrpc-microservices-with-docker-compose-file)
    - [166: TEST - Docker-compose Discount.Grpc microservices with SQLite](#166-test---docker-compose-discountgrpc-microservices-with-sqlite)
  - [Section 12: Consuming Discount.gRPC service from Basket Microservice when adding cart item (35 min)](#section-12-consuming-discountgrpc-service-from-basket-microservice-when-adding-cart-item-35-min)
    - [167: Introduction - Consuming Discount Grpc Service From Basket Microservice](#167-introduction---consuming-discount-grpc-service-from-basket-microservice)
    - [168: Consuming Discount Grpc Service From Basket Microservice When Adding Cart Item](#168-consuming-discount-grpc-service-from-basket-microservice-when-adding-cart-item)
    - [169: Consuming Discount Grpc Service From Basket API Microservice When Adding Cart -2](#169-consuming-discount-grpc-service-from-basket-api-microservice-when-adding-cart--2)
    - [170: Register Discount Grpc Client and Discount Grpc Service into the Basket.API](#170-register-discount-grpc-client-and-discount-grpc-service-into-the-basketapi)
    - [171: Test and Run Discount Grpc and Basket Microservice](#171-test-and-run-discount-grpc-and-basket-microservice)
    - [172: Add Grpc DiscountUrl Configuration in Basket.API image configuration on Docker](#172-add-grpc-discounturl-configuration-in-basketapi-image-configuration-on-docker)
    - [173-174: Test on Docker environment - Basket.API communicate with Discount.Grpc in Docker](#173-174-test-on-docker-environment---basketapi-communicate-with-discountgrpc-in-docker)
  - [Section 13: Ordering Microservices with DDD, CQRS and Clean Architecture (58 min)](#section-13-ordering-microservices-with-ddd-cqrs-and-clean-architecture-58-min)
    - [175: Introduction - Ordering Microservices with DDD, CQRS and Clean Architecture](#175-introduction---ordering-microservices-with-ddd-cqrs-and-clean-architecture)
    - [176: Create Asp.Net Web Api for Ordering.API Microservice in Microservices Solution](#176-create-aspnet-web-api-for-orderingapi-microservice-in-microservices-solution)
    - [177: Domain Analysis of Ordering Microservices: Models, UCs, Rest Apis, Databases](#177-domain-analysis-of-ordering-microservices-models-ucs-rest-apis-databases)
    - [178: Technical Analysis of Ordering Microservices: Architectures, Patterns, Libraries](#178-technical-analysis-of-ordering-microservices-architectures-patterns-libraries)
    - [179: SOLID, KISS, YAGNI, SoC, DIP - Common Principles](#179-solid-kiss-yagni-soc-dip---common-principles)
    - [180: Apply DDD, CQRS and Clean Architecture patterns in Ordering microservice](#180-apply-ddd-cqrs-and-clean-architecture-patterns-in-ordering-microservice)
    - [181: Domain Driven Design - DDD](#181-domain-driven-design---ddd)
    - [182: Clean Architecture](#182-clean-architecture)
    - [183: Clean Architecture with Domain Driven Design(DDD)](#183-clean-architecture-with-domain-driven-designddd)
    - [184: Code Structure on DDD and Clean Architecture Layers in Ordering Microservices](#184-code-structure-on-ddd-and-clean-architecture-layers-in-ordering-microservices)
    - [185: Create Clean Architecture Layers: Domain, Application, Infrastructure and API](#185-create-clean-architecture-layers-domain-application-infrastructure-and-api)
    - [186: Adding Project References Between Clean Architecture Layers](#186-adding-project-references-between-clean-architecture-layers)
    - [187: Adding Dependency Injections Between Clean Architecture Layers](#187-adding-dependency-injections-between-clean-architecture-layers)
  - [Section 14: Ordering.Domain layer with Tactical Domain-driven design patterns (1 hr 20 min)](#section-14-orderingdomain-layer-with-tactical-domain-driven-design-patterns-1-hr-20-min)
    - [188: Tactical Domain-Driven Design: Entities, Value Objects, Aggregates, Agg. Roots](#188-tactical-domain-driven-design-entities-value-objects-aggregates-agg-roots)
    - [189: Develop DDD Abstractions (Entity, Aggregate, DomainEvent) in Ordering.Domain](#189-develop-ddd-abstractions-entity-aggregate-domainevent-in-orderingdomain)
    - [190: Domain Modeling with Tactical DDD for Ordering Microservices](#190-domain-modeling-with-tactical-ddd-for-ordering-microservices)
    - [191: Develop Domain Modeling with DDD for Ordering Microservices](#191-develop-domain-modeling-with-ddd-for-ordering-microservices)
    - [192: Primitive Obsession and Strongly typed IDs in DDD](#192-primitive-obsession-and-strongly-typed-ids-in-ddd)
    - [193: Develop Strongly typed IDs for Order Entities](#193-develop-strongly-typed-ids-for-order-entities)
    - [194: Anemic-domain vs Rich-domain Model Entities Entities in DDD](#194-anemic-domain-vs-rich-domain-model-entities-entities-in-ddd)
    - [195: Develop DDD Rich-domain model Entity for Order Entities in Order.Domain Layer](#195-develop-ddd-rich-domain-model-entity-for-order-entities-in-orderdomain-layer)
    - [196: Develop ValueObjects (Address, Payment) DDD Rich-domain model Entity](#196-develop-valueobjects-address-payment-ddd-rich-domain-model-entity)
    - [197: Develop DDD Rich-domain model for Order Entities in Order.Domain Layer](#197-develop-ddd-rich-domain-model-for-order-entities-in-orderdomain-layer)
    - [198: Domain Events in DDD and Domain vs Integration Events](#198-domain-events-in-ddd-and-domain-vs-integration-events)
    - [199: Develop Order Created and Updated Domain Event in Ordering Microservices](#199-develop-order-created-and-updated-domain-event-in-ordering-microservices)
  - [Section 15: Ordering.Infrastructure layer with EF.Core code first and SQL Server (2 hr 13 min)](#section-15-orderinginfrastructure-layer-with-efcore-code-first-and-sql-server-2-hr-13-min)
    - [200: Develop Ordering.Infrastructure Layer with EF Core Code First Approach](#200-develop-orderinginfrastructure-layer-with-ef-core-code-first-approach)
    - [201: EF Core 8 Features, Code First Approach, Migrations and SQL Server Connection](#201-ef-core-8-features-code-first-approach-migrations-and-sql-server-connection)
    - [202: Steps of EF Core Developments for Ordering.Infrastructure](#202-steps-of-ef-core-developments-for-orderinginfrastructure)
    - [203: Install EF Core Nuget Packages in Ordering.Infrastructure](#203-install-ef-core-nuget-packages-in-orderinginfrastructure)
    - [204: Develop EF Core DBContext Object for Storing Entities in Ordering.Infrastructure](#204-develop-ef-core-dbcontext-object-for-storing-entities-in-orderinginfrastructure)
    - [205: Mapping DDD Objects to EF Entities - Develop EF Core Entity Configurations](#205-mapping-ddd-objects-to-ef-entities---develop-ef-core-entity-configurations)
    - [206: EF Core 8 Relations and DDD ValueObject Mapping with ComplexType and ComplexProp](#206-ef-core-8-relations-and-ddd-valueobject-mapping-with-complextype-and-complexprop)
    - [207: Mapping DDD Objects to EF Entities - Develop Order Entity Configurations](#207-mapping-ddd-objects-to-ef-entities---develop-order-entity-configurations)
    - [208: EF Core SQL Server Connection String in appsettings.json file](#208-ef-core-sql-server-connection-string-in-appsettingsjson-file)
    - [209: Register EF Core DbContext in Asp.Net DependencyInjection Tool for SQL Server](#209-register-ef-core-dbcontext-in-aspnet-dependencyinjection-tool-for-sql-server)
    - [210-211: Create EF Core Migrations for ApplicationDbContext in Ordering.Infrastructure](#210-211-create-ef-core-migrations-for-applicationdbcontext-in-orderinginfrastructure)
    - [212: Setup SQL Server DB using Docker-compose file for Multi-container Docker Env](#212-setup-sql-server-db-using-docker-compose-file-for-multi-container-docker-env)
    - [213: Run Docker-Compose on Visual Studio to setup SQL Server DB on Docker](#213-run-docker-compose-on-visual-studio-to-setup-sql-server-db-on-docker)
    - [214: Apply EF Core Migrations to SQL Server DB with Update-Database Command](#214-apply-ef-core-migrations-to-sql-server-db-with-update-database-command)
    - [215: Auto Migrate EF Core Entities to SQL Server when Application Startup w/ Coding](#215-auto-migrate-ef-core-entities-to-sql-server-when-application-startup-w-coding)
    - [216: Seed SQL Server OrderDb using EF Core when Application Startup with Coding](#216-seed-sql-server-orderdb-using-ef-core-when-application-startup-with-coding)
    - [217: Seed Product and Orders in SQL Server OrderDb using EF Core when App Startup](#217-seed-product-and-orders-in-sql-server-orderdb-using-ef-core-when-app-startup)
    - [218: Run Order Microservices to Migrate and Seed OrderDb in SQL Server using EF Core](#218-run-order-microservices-to-migrate-and-seed-orderdb-in-sql-server-using-ef-core)
    - [219: EF Core Interceptors: SaveChangesInterceptor for Auditing Entities](#219-ef-core-interceptors-savechangesinterceptor-for-auditing-entities)
    - [220: Develop SaveChangesInterceptor to Auditing Entities for Order Entities](#220-develop-savechangesinterceptor-to-auditing-entities-for-order-entities)
    - [221: Run\&Test Order Microservices for Audit with EF Save Changes Interceptor](#221-runtest-order-microservices-for-audit-with-ef-save-changes-interceptor)
    - [222: Dispatch Domain Events w/ EF Core SaveChangesInterceptor](#222-dispatch-domain-events-w-ef-core-savechangesinterceptor)
    - [223: Develop DispatchDomainEventsInterceptor to Trigger Domain Event Handlers](#223-develop-dispatchdomaineventsinterceptor-to-trigger-domain-event-handlers)
    - [224: Run\&Test Order Microservices for Dispatch DomainEvents with EF Save Changes](#224-runtest-order-microservices-for-dispatch-domainevents-with-ef-save-changes)
  - [Section 16: Ordering.Application layer with CQRS \& MediatR (1 hr 49 min)](#section-16-orderingapplication-layer-with-cqrs--mediatr-1-hr-49-min)
    - [225: Develop Ordering.Application Layer with CQRS and MediatR implement the Command](#225-develop-orderingapplication-layer-with-cqrs-and-mediatr-implement-the-command)
    - [226: CQRS (Command Query Responsibility Segregation) Pattern in Ordering microservice](#226-cqrs-command-query-responsibility-segregation-pattern-in-ordering-microservice)
    - [227: Event Sourcing Pattern](#227-event-sourcing-pattern)
    - [228: CQRS with Event Sourcing Pattern](#228-cqrs-with-event-sourcing-pattern)
    - [229: Eventual Consistency Principle](#229-eventual-consistency-principle)
    - [230: Analysis of Ordering Microservice Application Layer](#230-analysis-of-ordering-microservice-application-layer)
    - [231: Implement CQRS Command and Command Handler Patterns with MediatR](#231-implement-cqrs-command-and-command-handler-patterns-with-mediatr)
    - [232: Develop Ordering.Application Folder Structure for CQRS](#232-develop-orderingapplication-folder-structure-for-cqrs)
    - [233: Develop Dto Classes for Orders in Ordering.Application Layer](#233-develop-dto-classes-for-orders-in-orderingapplication-layer)
    - [234: Develop Orders CreateOrderCommand and Handler in Ordering.Application Layer](#234-develop-orders-createordercommand-and-handler-in-orderingapplication-layer)
    - [235: Develop IApplicationDbContext for injection EFCore DB Context object in Ordering](#235-develop-iapplicationdbcontext-for-injection-efcore-db-context-object-in-ordering)
    - [236: Develop Orders CreateOrderCommandHandler using IApplicationDbContext in Ordering](#236-develop-orders-createordercommandhandler-using-iapplicationdbcontext-in-ordering)
    - [237: Develop Orders UpdateOrderCommand and Handler using IApplicationDbContext](#237-develop-orders-updateordercommand-and-handler-using-iapplicationdbcontext)
    - [238: Develop Orders DeleteOrderCommand and Handler using IApplicationDbContext](#238-develop-orders-deleteordercommand-and-handler-using-iapplicationdbcontext)
    - [239: Develop MediatR Pipeline Behaviours (Validation, Logging) in Ordering.App](#239-develop-mediatr-pipeline-behaviours-validation-logging-in-orderingapp)
    - [240: Develop Domain Event Handlers with MediatR INotificationHandler in Ordering.App](#240-develop-domain-event-handlers-with-mediatr-inotificationhandler-in-orderingapp)
    - [241: Develop Domain Event Handlers with MediatR INotificationHandler in Ordering.App](#241-develop-domain-event-handlers-with-mediatr-inotificationhandler-in-orderingapp)
    - [242: Develop Order Queries with CQRS and MediatR in Ordering.Application Layer](#242-develop-order-queries-with-cqrs-and-mediatr-in-orderingapplication-layer)
    - [243: Develop Extention method for ProjectToOrderDto use in GetOrders Methods](#243-develop-extention-method-for-projecttoorderdto-use-in-getorders-methods)
    - [244: Develop GetOrdersByCustomer Queries w/ CQRS and MediatR in Ordering.Application](#244-develop-getordersbycustomer-queries-w-cqrs-and-mediatr-in-orderingapplication)
    - [245: Develop Pagination Class for Query GetOrders using CQRS and MediatR](#245-develop-pagination-class-for-query-getorders-using-cqrs-and-mediatr)
    - [246: Develop GetOrders Query apply Pagination using CQRS and MediatR in Ordering.App](#246-develop-getorders-query-apply-pagination-using-cqrs-and-mediatr-in-orderingapp)
  - [Section 17: Ordering.API layer exposing minimal API endpoint with Carter and REPR pattern (1 hr 29 min)](#section-17-orderingapi-layer-exposing-minimal-api-endpoint-with-carter-and-repr-pattern-1-hr-29-min)
    - [247: Develop Ordering.API Layer with Exposing Minimal REST APIs w/ Carter](#247-develop-orderingapi-layer-with-exposing-minimal-rest-apis-w-carter)
    - [248: Analysis the Ordering.API layer in Clean Architecture](#248-analysis-the-orderingapi-layer-in-clean-architecture)
    - [249: Program.cs and Dependency Injection class in Ordering.API Layer](#249-programcs-and-dependency-injection-class-in-orderingapi-layer)
    - [250: Developing Order Endpoints for REST APIs in Ordering.API Layer](#250-developing-order-endpoints-for-rest-apis-in-orderingapi-layer)
    - [251: Developing CreateOrder Endpoint for REST APIs in Ordering.API Layer](#251-developing-createorder-endpoint-for-rest-apis-in-orderingapi-layer)
    - [252: Developing UpdateOrder Endpoint for REST APIs in Ordering.API Layer](#252-developing-updateorder-endpoint-for-rest-apis-in-orderingapi-layer)
    - [253: Developing DeleteOrder Endpoint for REST APIs in Ordering.API Layer](#253-developing-deleteorder-endpoint-for-rest-apis-in-orderingapi-layer)
    - [254: Developing GetOrdersByName Endpoint for REST APIs in Ordering.API Layer](#254-developing-getordersbyname-endpoint-for-rest-apis-in-orderingapi-layer)
    - [255: Developing GetOrdersByCustomer Endpoint for REST APIs in Ordering.API Layer](#255-developing-getordersbycustomer-endpoint-for-rest-apis-in-orderingapi-layer)
    - [256: Developing GetOrders Endpoint w/ Pagination for REST APIs in Ordering.API Layer](#256-developing-getorders-endpoint-w-pagination-for-rest-apis-in-orderingapi-layer)
    - [257: Testing Ordering.API Endpoints with CQRS and Clean Architecture Layers](#257-testing-orderingapi-endpoints-with-cqrs-and-clean-architecture-layers)
    - [258: Test Create Order Endpoint with CQRS and Clean Architecture Layers in Ordering](#258-test-create-order-endpoint-with-cqrs-and-clean-architecture-layers-in-ordering)
    - [259: Test Update Order Endpoint with CQRS and Clean Architecture Layers in Ordering](#259-test-update-order-endpoint-with-cqrs-and-clean-architecture-layers-in-ordering)
    - [260: Test Get Order Endpoints with CQRS and Clean Architecture Layers in Ordering](#260-test-get-order-endpoints-with-cqrs-and-clean-architecture-layers-in-ordering)
    - [261: Test Delete Order Endpoint with CQRS and Clean Architecture Layers in Ordering](#261-test-delete-order-endpoint-with-cqrs-and-clean-architecture-layers-in-ordering)
    - [262: Cross-Cutting Concerns Custom Exception Handler in Ordering Microservice](#262-cross-cutting-concerns-custom-exception-handler-in-ordering-microservice)
    - [263: Health Checks for Ordering Microservices with EF.Core and SQL Server](#263-health-checks-for-ordering-microservices-with-efcore-and-sql-server)
  - [Section 18: Microservices async communication w/ RabbitMQ \& MassTransit for checkout order (3 hr 2 min)](#section-18-microservices-async-communication-w-rabbitmq--masstransit-for-checkout-order-3-hr-2-min)
    - [264: Introduction - Microservices Async Communication w/ RabbitMQ \& MassTransit](#264-introduction---microservices-async-communication-w-rabbitmq--masstransit)
    - [265: Microservices Asynchronous Communication](#265-microservices-asynchronous-communication)
    - [266: Benefits of Asynchronous Communication](#266-benefits-of-asynchronous-communication)
    - [267: Challenges of Asynchronous Communication](#267-challenges-of-asynchronous-communication)
    - [268: Fan-Out Publish/Subscribe Messaging Pattern](#268-fan-out-publishsubscribe-messaging-pattern)
    - [269: Event-Driven Microservices Architecture](#269-event-driven-microservices-architecture)
    - [270: What is RabbitMQ and Main Components of RabbitMQ (Producer, Queue, Consumer..)](#270-what-is-rabbitmq-and-main-components-of-rabbitmq-producer-queue-consumer)
    - [271: RabbitMQ Exchange Types: Direct, Fanout, Topic, and Headers](#271-rabbitmq-exchange-types-direct-fanout-topic-and-headers)
    - [272: Domain Analysis of Async Communication between Basket and Ordering Microservices](#272-domain-analysis-of-async-communication-between-basket-and-ordering-microservices)
    - [273: Technical Analysis of Async Communication between Basket and Ordering ms](#273-technical-analysis-of-async-communication-between-basket-and-ordering-ms)
    - [274: Steps of Developing Async Communication between Basket and Ordering Microservice](#274-steps-of-developing-async-communication-between-basket-and-ordering-microservice)
    - [275: Create BuildingBlocks.Messaging Shared Class Library for Common Async connection](#275-create-buildingblocksmessaging-shared-class-library-for-common-async-connection)
    - [276: Develop BasketCheckout Event in BuildingBlocks.Messaging Shared Class Library](#276-develop-basketcheckout-event-in-buildingblocksmessaging-shared-class-library)
    - [277: Develop MassTransit Extention Methods to Register RabbitMQ connection into DI](#277-develop-masstransit-extention-methods-to-register-rabbitmq-connection-into-di)
    - [278: Develop MassTransit Extention Methods to Register RabbitMQ connection into DI -2](#278-develop-masstransit-extention-methods-to-register-rabbitmq-connection-into-di--2)
    - [279: Publish BasketCheckout Event from Basket Microservices](#279-publish-basketcheckout-event-from-basket-microservices)
    - [280: Develop BasketCheckout Feature Folder to Expose POST Endpoint and Publish Event](#280-develop-basketcheckout-feature-folder-to-expose-post-endpoint-and-publish-event)
    - [281: Develop Basket Checkout Handler Method to Publish event to RabbitMQ-MassTransit](#281-develop-basket-checkout-handler-method-to-publish-event-to-rabbitmq-masstransit)
    - [282: Dual-write Problem and Outbox Pattern](#282-dual-write-problem-and-outbox-pattern)
    - [283: Ordering Microservices to Subscribe-Consume BasketCheckout event from RabbitMQ](#283-ordering-microservices-to-subscribe-consume-basketcheckout-event-from-rabbitmq)
    - [284: Register MassTransit RabbitMQ packages into Ordering.Application DI](#284-register-masstransit-rabbitmq-packages-into-orderingapplication-di)
    - [285: OrderCreated Integration Event: How Domain Event leads to Integration Event](#285-ordercreated-integration-event-how-domain-event-leads-to-integration-event)
    - [286: Develop Basket Checkout Event Consumer integration event handler class](#286-develop-basket-checkout-event-consumer-integration-event-handler-class)
    - [287: Develop Basket Checkout Event Consumer integration event handler class - 2](#287-develop-basket-checkout-event-consumer-integration-event-handler-class---2)
    - [288: Saga Pattern for Distributed Transactions](#288-saga-pattern-for-distributed-transactions)
    - [289: Publish OrderCreated Integration event for Order Fulfillment microservices](#289-publish-ordercreated-integration-event-for-order-fulfillment-microservices)
    - [290: Aspnet Feature Management Develop Feature Flag for OrderCreated Event](#290-aspnet-feature-management-develop-feature-flag-for-ordercreated-event)
    - [291: Setup RabbitMQ for Async Communication using Docker-compose file](#291-setup-rabbitmq-for-async-communication-using-docker-compose-file)
    - [292: Run Docker-Compose on Visual Studio to setup RabbitMQ on Docker](#292-run-docker-compose-on-visual-studio-to-setup-rabbitmq-on-docker)
    - [293: TEST- Publish BasketCheckout Event in Basket.API Microservices](#293-test--publish-basketcheckout-event-in-basketapi-microservices)
    - [294: TEST- Subscribe/Consume BasketCheckout Event in Ordering.API Microservices](#294-test--subscribeconsume-basketcheckout-event-in-orderingapi-microservices)
    - [295: TEST- Set OrderFullfilment feature = false. Re-Test Publish - Subscribe/Consume](#295-test--set-orderfullfilment-feature--false-re-test-publish---subscribeconsume)
    - [296: Containerize and Configure Basket, Ordering and RabbitMQ Containers](#296-containerize-and-configure-basket-ordering-and-rabbitmq-containers)
    - [297: Containerize and Orchestrate Ordering microservices with Docker \& Docker-Compose](#297-containerize-and-orchestrate-ordering-microservices-with-docker--docker-compose)
    - [298: TEST- Docker-Compose Microservices - Publish/Subscribe BasketCheckout Event](#298-test--docker-compose-microservices---publishsubscribe-basketcheckout-event)
  - [Section 19: Build API GW with Yarp reverse proxy applying GW routing pattern (1 hr 26 min)](#section-19-build-api-gw-with-yarp-reverse-proxy-applying-gw-routing-pattern-1-hr-26-min)
    - [299-307: Introduction - API Gateways with Yarp Reverse Proxy, concept and understanding](#299-307-introduction---api-gateways-with-yarp-reverse-proxy-concept-and-understanding)
    - [308: Create YarpApiGateway Microservices into ECommerce Solution](#308-create-yarpapigateway-microservices-into-ecommerce-solution)
    - [309: Develop Yarp Reverse Proxy in YarpApiGateway Microservices](#309-develop-yarp-reverse-proxy-in-yarpapigateway-microservices)
    - [310 - 312: Implement API Gateway using Yarp Reverse Proxy in YarpApiGateway Microservices](#310---312-implement-api-gateway-using-yarp-reverse-proxy-in-yarpapigateway-microservices)
    - [313: Rate Limiting to Yarp Reverse Proxy as an API Gateway in YarpApiGateway](#313-rate-limiting-to-yarp-reverse-proxy-as-an-api-gateway-in-yarpapigateway)
    - [314 - 317: Containerize and Orchestrate YarpApiGateway as an API Gateway in Docker-Compose](#314---317-containerize-and-orchestrate-yarpapigateway-as-an-api-gateway-in-docker-compose)
  - [Section 20: Building shopping web client application with Refit HttpClientFactory library (2 hr 45 min)](#section-20-building-shopping-web-client-application-with-refit-httpclientfactory-library-2-hr-45-min)
    - [318 - 321: Introduction - Shopping Web Client Application with Refit HttpClientFactory library](#318---321-introduction---shopping-web-client-application-with-refit-httpclientfactory-library)
    - [322: Developing Shopping Web Application Microservices](#322-developing-shopping-web-application-microservices)
    - [323 - 325: Create models for web application to consume api via yarp reverse proxy](#323---325-create-models-for-web-application-to-consume-api-via-yarp-reverse-proxy)
    - [326: Develop Service Classes for consume YarpApiGateway](#326-develop-service-classes-for-consume-yarpapigateway)
    - [327: Refit HttpClientFactory Library: The automatic type-safe REST library](#327-refit-httpclientfactory-library-the-automatic-type-safe-rest-library)
  - [Section 21: End of Course \& Bonus lectures](#section-21-end-of-course--bonus-lectures)
  - [999: Troubleshooting](#999-troubleshooting)
    - [02: Install EF Tools](#02-install-ef-tools)
    - [03: Ref. Git repo](#03-ref-git-repo)

C# code repository - learning developing complex micro service.

## Section 01 to 05: Develop Catalog.API with Vertical slice architecture and CQRS

1. Created new repository on Git, ref. - Repo: [eShop.MicroService.net8](https://github.com/pandyamehul/eShop.MicroService.net8).

2. Cloned repo to local folder directlry using Git.clone command or using Visual studio clone option.

    ```cmd
    git clone https://github.com/pandyamehul/eShop.MicroService.net8.git
    ```

    OR

    ![Clone Catalog API](/img/20240420.1710.Clone.Catalog.API.png)
    ![Clone Catalog API](/img/20240420.1710.Clone.Catalog.API.2.png)

    Clone repo to local folder on computer.

3. Open folder in visual studio and create new project using "Blank Solution" visual studio template.
4. Create new solution folder name "Services\Catalog". Commit code and push to remorte branch from visual studio.
5. Add new ASP.net core empty project for "Catalog.API" place under "\src\service\catalog" folder.
6. Setup application port. This can be done using Project properties --> navigate to debug section --> open debug launch profile or directly update the appsettings.json file.
7. Catalog API service will use http port 5000 and https port 5050.
8. To understand domain concept of Catalog micro service go through PPT page 113 to 123.
9. To understand technical concept of Catalog micro service go through PPT page 124 to 130.
10. Read through slide 149, to understand various topics.
11. Implemnted code as per course. Added CQRS interfaces and then Create product handlers, using MediatR library.
12. Seperated command and query using CQRS design pattern.
13. Created abstraction on MediatR using CQRS. Added generic implementation and building block IRequest --> IQuery --> IRequestHandler --> IQueryHandler and IRequest --> ICommand --> IRequestHandler --> ICommanHandler.

### 49: Implement CQRS abstractions Icommand into  vertical slice feature handler class

- Implement command handler for create product feature in catalog api.
- Refactor create product command to use ICommand abstraction instead of IRequest.
- Create product entity from command object. Updated CreateProductHandler.cs file under Handle method create new product entity.

### 50: Develop Create Product endpoint with minimal API and Cater

- Implement product endpoint as minimal api with carter library to expose http end point.
- CQRS and request pipeline - develop request and response object.
- Carter library extends the capability of ASP.net core minimal api. It provides more structured way to organize endpoint and simplify creation of http request handler. Ref. slide 155.
- added CreateRecordRequest and CreateRecordResponse objects in "CreateProductEndpoint" class and also reference of Carter library into building block.

### 51,52: Develop POST endpoint with Carter implements ICarterModule with minimal API

- Open CreateProductEndpoint and inherit ICaterModule interface.
- Implement "AddRoute" method in CreateProductEndpoint.
- Map request to create product command to pass to command handler. Use MediatR library and trigger MideateR command handler.
- In order to pass values from request to command object need mapping object and this is done using mapping library "Mapster".
- Mapster - is high performance and flexible mapping library that map objects.
- Mapster is used to map request object to command object and response to result object.
- All common libraries and generic implementations are added to the building Block class library.
- Add "Mapster" library into Building block project under common class libraries.
- Moved some of repeated used nuget reference to global using. Namespace used many places are moved to "GlobalUsing" class file.
- Following code block added to product end point.

    ```c#
    public void AddRoutes(IEndpointRouteBuilder app)
    {
        app.MapPost("/products", async(CreateProductRequest request, ISender sender) =>
        {
            var command = request.Adapt<CreateProductCommand>();
            var result = await sender.Send(command);
            var response = result.Adapt<CreateProductResponse>();
            return Results.Created($"/products/{response.Id}", response);
        })
            .WithName("CreateProduct")
            .Produces<CreateProductResponse>(StatusCodes.Status201Created)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .WithSummary("Create Product")
            .WithDescription("Create Product");
        throw new NotImplementedException();
    }
    ```

### 53: Register MediatR, Carter and Mapster libraries to ASP.net dependency injection services

- Open program.cs file and add dependency injection services and configre the http request piepline.
- To register these libraries following code block added to Program.cs under the request pipeline.

    ```c#
    //Add Services to container
    builder.Services.AddCarter();
    builder.Services.AddMediatR(config =>
    {
        config.RegisterServicesFromAssemblies(typeof(Program).Assembly);
    });
    var app = builder.Build();
    //Configure HTTP request pipeline
    app.MapCarter();
    ```

### 54: Test catalog API - CreateProduct POST request - Debug Carter and MediatR libraries

- Build and run micro service using https option and end point.
- Initially when project started it run but when sent POST request it didn't run because Carter library was referenced into the "BuildingBlock" project and we registered program assembly. Thus we got 404 error.
- To resolve this issue, carter library referenced into the Catalog API instead of building block.
- After moving reference to catalog API POSt request seems worked.

## Section 6: Develop Catalog.API Infrastructure, Handler and Endpoint Classes for CRUD

Infrastructure -Data Concerns for Catalog API -Marten .NET Transactional Document DB for PostgreSQL Database

### 55: Introduction - Develop Catalog.API Infrastructure, Handler and Endpoint Classes

Ref. slide# 157 - 159

### 56: Infrastructure - Data concerms for Catalog API - Marten .NET Transactional Db

Ref. slide# 160 - 164

### 57: Opening sessions in Marten as Document Db

Ref. slide# 165

### 58: Develop Command Handler to save product to Document Db using Marten library

- To deal with database added reference of Marten nuget package reference.
- Added following lines of code to "CreateProductHandler" under handle method.

    ```c#
    //Injected IDocumentSession object
    internal class CreateProductHandler(IDocumentSession session)

    // Save to Db
    session.Store( product );
    await session.SaveChangesAsync(cancellationToken);

    // Return newly created Db id
    return new CreateProductResult(product.Id);
    ```

### 59: Register and configure Marten Document Db library into program.cs asp.net DI

- To register library and to configure db added following code and configurations

    ```c#
    //Program.cs
    builder.Services.AddMarten( options =>
    {
        options.Connection(builder.Configuration.GetConnectionString("Database")!);
    }).UseLightweightSessions();
    ```

    ```json
    //appsettings.json
    "ConnectionString": {
        "Database": "server=localhost; port=5432; Databse: CatalogDb; User Id=postgres; Password=postgres; Include Error Detail=true;"
    },
    ```

### 60: EShops microservice - Deployment Strategy

- Ref. slide 167-

### 61: Setup PostgresSQL Db using Docker-compose file for Multi-container Docker Env

Following steps were added to enable docker environment for development.

- Right click on Catalog API solution. Select Add --> Container Orchestrator support.
- Select "Docker Compose"
- Select "Linux" environment
- New additional files will be added to the solution

### 62: Add PostgresSQL into Docker compose file for multi container docker environment

- Added below configurations in docker-compose yaml files

```yaml
#docker-compose.yml
services:
  catalogdb:
    image: postgres

volumes:
  postgres_catalog:

#docker-compose.override.yml
services:
 catalogdb:
   container_name: eshop.catalogdb
   environment:
    - POSTGRES_USER=postgres
    - POSTGRES_PASSWORD=postgres
    - POSTGRES_DB=CatalogDb
   restart: always
   ports:
    - "5432:5432"
   volumes:
    - eshop_postgres_catalog:/var/lib/postgresql/data/ 
```

### 63: Run docker compose on visual studio to setup PostgreSQL DB on docker

- After fixing issue with docker file, executed docker compose from visual studio.
- It downloaded necessary images and spin container to run database.
- To connect to db following steps were performed

    ```pwsh
    docker ps
    docker exec -it <container_id> bash
    #this will lands to the postgres console
    psql -U postgres
    \l #to list available dbs
    \c CatalogDb # to connect to Db
    \d #to list tables
    ```

### 64: Connect Postgres Db from local catalog microservice & send POST request

- Ref. slide Title: **EShop Microservices Deployment Strategy** Ref. deck 149 (Udemy) / 168 (local pdf)
- Run docker compose from Visual Studio
- Run Catalog API in https mode and see whether Db inside Docker conytainer is accessible from application.
- Send Post request to create 1st product
- Validate whether product entry is created in Db.

### 65: Develop GetProduct Feature in Vertical Slice Architecture with CQRS, MediatR in Handler class

- Ref. Slides
  - **Rest API Endpoints of Catalog Microservice** (152 / 154)
  - **CQRS and MediatR Request LifeCycle** (154 / 152)

- Created new folder "GetProduct" and added below 2 new classes viz. GetProductEndpoint.cs, GetProductsQueryHandler.cs to support GET operation of API for Catalog microservice.

### 66: Develop GET GetEndpoint with minimal API and Carter

- Implemented GET operation in GetProductEndpoint.cs

### 67: Test GET Product endpoint connecting to Docker Postgres Container

- **Rest API Endpoints of Catalog Microservices** (149/154)
- **EShop Microservices Deployment Strategy** (150/168)

### 68: Create API Client collection for EShop

- **Port Numbers for Catalog.API Microservice** (152/171)

### 69: Develop GetProductById handler with CQRS & MediatR

- **Developing Catalog.API Microservices** (155/170)
- **CQRS and MediatR Request LifeCycle** (154 / 152)
- Created new folder "GetProductById"
- Implemented new class - GetProductByIdQueryHandler

### 70: Develop GetProductById GET endpoint with minimal API and Carter

- **CQRS and MediatR Request LifeCycle** (156 / 152)
- Implemented new class - GetProductById and implemented GET /product/{id} operation

### 71: Test GetProductById endpoint connecting to Docker postgres container

- Run docker compose
- Run API
- From API Client send GET request and validate working flow

### 72: Develop GetProductByCategory handler using CQRS and MediatR

- Created new folder "GetProductByCategory"
- Added new class and implementation - "GetProductByCategoryHandler.cs"

### 73: Develop GetProductByCategory GET endpoint with minimal API and Carter

- Implemented new class - GetProductByCategoryQuery and implemented GET /products/categoty/{category} operation

### 74: Test GetProductByCategory endpoint connecting to Docker postgres container

- Run docker compose
- Run API
- From API Client send GET request and validate working flow

### 75: Develop UpdateProduct handler using CQRS and MediatR

- Created new folder "UpdateProduct"
- Added new class and implementation - "UpdateProductHandler.cs"

### 76: Develop UpdateProduct PUT endpoint with minimal API and Carter

- Implemented new class - UpdateProductByIdQuery and implemented PUT /products operation

### 77: Test UpdateProduct endpoint connecting to Docker postgres container

- skipped

### 78: Develop DeleteProduct handler using CQRS and MediatR

- Created new folder "DeleteProduct"
- Added new class and implementation - "DeleteProductHandler.cs"

### 79: Develop DeleteProduct PUT endpoint with minimal API and Carter

- Implemented new class - DeleteProductByIdQuery and implemented Delete /products/{id} operation

### 80: Test DeleteProduct endpoint connecting to Docker postgres container

- Run docker compose
- Run API
- From API Client send PUT, DELETE request and validate working flow

## Section 7: Develop Catalog.API Cross-cutting concerns

### 81: Introduction - Develop Catalog.API Cross-cutting concerns

- MediatR pipeline behaviour & Fluent validation library
- Logging & validation pipeline behaviouds
- Global handling exceptions in ASP.Net Core
- Seeding catalog database with Marten
- Health check for Catalog microservices with PostgresDb
- Develop pagination for GetProducts Query
- Containerize & orchestrate Catalog.API microservice with Docker and Docker-Compose

Ref. document - 177, 178 & 179

### 82: MeditR pipeline behaviours & Fluent validation library

Ref. document - 180, 181

### 83: Add cross cutting concerns into Building blocks class library for all projects

Ref. document - 181, 182, 183

- Imported package to building block solution --> FluentValidation.DependencyInjectionExtensions

### 84: Cross cuttig concerns - validation with abstractvalidator using Fluent validation

- Fluent libraries and validation implemented in Create Product operation.

### 85: Validation pipeline behavioud with MediatR using Fluent validation library

- Created new folder "Behaviours" in building block common library project.
- Added "ValidationBehaviour.cs" class and implementation for generic implementation.
- Register Validator in pipeline - every request will pass through validation using fluent library.

### 86: Remove Manual Validation and Test validation behaviour pipeline with MediatR

- Removed local validation behaviour.
- Register validation behaviour in pipeline and implemented generic request validation.
- Updated create product, program and validation behaviour class.
- Post changes validate request whether still performing validation as expected.

### 87: Develop CRUD Command Validation with Fluent validation pipeline behaviour

- Implemented validation "UpdateProductCommandValidator" class in "UpdateProductHandler.cs"
- Implemented validation "DeleteProductCommandValidator" class in "DeleteProductHandler.cs"
- Run application and check Validation is working as expected.

### 88: Global Exception Handling in ASP.Net Core with app.UseExceptionHandler

- Implemented "app.UseExceptionHandler()" in "Program.cs" application pipeline. to add global ASP.net exception handling in request pipeline.

### 89: BuildingBlocks Handling Exceptions Generic way w/ app.UseExceptionHandler

- In "BuildingBlocks" project, added new folder to "Exceptions".
- Added new class "NotFoundException", "BadRequestException", "InternalServerException" and implementation.
- Inherited "NotFoundException" class in "ProductNotFoundException" - passed Guid.
- Updated API implementation "UpdateProduct", "GetProdyctById" and "GetProductBYCategory".

### 90: Global Exception Handling with IExceptionHandler interface in Asp.net Core

- In "BuildingBlocks" project, added new sub folder "Handler" under "Exceptions" folder.
- Implemented "CustomExceptionHandler" class for Global Exception Handling with IExceptionHandler.
- Intention is to capture customer exception and also globla exception if not defined.

### 91: Register Custom Exception Handling into Asp.net with AddExceptionHandler method

- Refactor exception in "Program.cs" in application run pipeline.
- Removed old custom implementation and plug in generic custom exception handling in the application.

### 92: Logging Behavior in MediatR Pipeline for Cross-cutting concerns

- Q: How to enable centralize logginc across microservices consistant manner? for debugging and monitoring.
- Added "LoggingBehaviour" generic logging class.
- Injected logging behaviour in request pipeline.
- Removed existing logging from services to leverage generic logging.

### 93: Test Logging Behaviour for all MediatR Requests on Catalog.API microservices

- Remove logging from each API endpoint
- Validate logging by calling APIs

### 94: Seeding CatalogDb with Marten Initial Baseline Data (IInitialData interface)

- Created new folder under API callled "Data" and added class "CatalogInitialData" to populate default product.
- Updated "Program.cs" and added condition in request pipeline if dev environment then add some initial set of data.
- Refactored code for initial data support.

### 95: Test Seeding Initial Data with Marten on PostgresDB for Catalog.API microservice

- To test performed below steps
- From visual studio selected docker as start up project and run docker-compose without debug mode.
- Ensure postgres docker db is up and running.
- Drop existing product table from CatalogDb database.
- Change start up project as Catalog API and see default products are getting installed or not.
- Validate new table is created and also data is getting populated either by connecting to db or calling list API.

### 96: Develop Pagination for GetProducts Query with ToPagedListAsync extention method

- Added support of pagination in GetProducts with addition of page number and size parameters.
- Updated end point and handler class of GetProducts.

### 97: Test Pagination for GetProducts Query with ToPagedListAsync extention method

- Validate GetProducts end point by providing page number and page size parameters.

### 98: Health Check for Catalog Microservices with PostgresDB

- Added below nuget package to support health check of the web services

  ```xml
      <PackageReference Include="AspNetCore.HealthChecks.NpgSql" Version="9.0.0" />
      <PackageReference Include="AspNetCore.HealthChecks.UI.Client" Version="9.0.0" />
  ```

- Updated program.cs in build and configure pipeline to add support for health checks
- Validate health status using /health url

### 99: Containerize Catalog.API microservices with Docker

- Updated "docker-compose-overwrite" file.
- Added support for ASP.net Catalog.API service support

### 100: Orchestrate Catalog.API microservices with Docker-compose file

- Review and understand Catalog.API docker support

### 101: TEST - Docker-compose Catalog.API microservices with PostgresDB

- Run docker engine.
- Run docker compose and see db and catalog service.
- Validate Catalog service running from docker.

## Section 8: Basket Microservices with Vertical Slice Architecture and CQRS

### 102: Introduction - Basket Microservices with Vertical Slice Architecture and CQRS

Following are key learnings point:

- ASP.NET Core Minimal APIs for building fast HTTP APIs-fully functioning REST endpoints and top-level Pragram.cs
- Vertical Slice Architecture implementation with Feature folders and single .cs file includes.
- CQRS implementation using MediatR library.
- Marten library for .NET Transactional Db on Postgres SQL.
- Repository Pattern implementation over Marten and Redis cache.
- Carter for Minimal API endpoint definition.
- FluentValidation to validate inputs and add MediatR validation pipeline.
- DockerFile and docker-compose file for running Basker microservice and Postgres SQL database in docker environment.

### 103: Create Asp.Net Web API for Basket.API Microservice in Microservices Solution

- Created "Basket" folder under src/Service folder.
- Add new ASP.net Core empty project with docket support and skip top lines, enabled https and docker support with linux container.
- Arranged solution according to folder structure.
- Refactored program.cs class.

### 104: Set Port Numbers for Basket.API Microservice - Modify Launch Settings

- Setup application port number in launchsettings.json file.

### 105: Domain Analysis of Basket Microservices: Models, UCs, Rest Apis, Databases

- Ref. slide# 192 to 198

### 106: Technical Analysis of Basket Microservices: Architectures, Patterns, Libraries

- Ref. slide# 199 to 205

### 107: Develop Basket.API Microservices Creating Domain Entities

- Created new folder "Model" under the root of Basket.API solution
- Created 2 models classes viz. ShoppingCartItem.cs and ShoppingCart.cs

### 108: Develop Vertical Slice Feature Folder with CQRS and MediatR

- Setup Vertical Slice Feature Folder structure and creation of endpoint and handler class for each operations
- New Folder "Basket" and sub folders "GetBasket", "StoreBasket", "DeleteBasket" created.
- Created skeleton classes for each operation viz. endpoint and handle class.

### 109: Develop GetBasket Feature Handler class with CQRS and MediatR

- Implemented GetBasketHandler class with dummy object response.

### 110: Develop Get Basket Endpoint with Minimal Apis and Carte

- Implemente GetBasketEndpoint class.

### 111: Develop StoreBasket Feature Handler class with CQRS and MediatR

- Implemeted StoreBasketCommandHandler class

### 112: Develop Store Basket Endpoint with Minimal Apis and Carter

- Implemeted Store Basket Endpoint

### 113: Develop DeleteBasket Feature Handler class with CQRS and MediatR

- Implemented "DeleteBasketHandler" and "DeleteBasketCommandValidator".

### 114: Develop Delete Basket Endpoint with Minimal Apis and Carter

- Implemented "DeleteBasketEndpoint"

### 115: Register MediatR and Carter libraries into Asp.Net Dependency Injection Service

- Updated "Program.cs"
- Registered MediatR and Carter libraries into Asp.Net Dependency Injection Service

### 116: Test Basket API - GET and POST Basket Request - Debug Carter Minimal API

- Run application locally
- Validate end point with dummy / mock responses
- Ref. "BasketRequest.rest" client file.

### 117: Infrastructure - Data Concerns for Basket API - Marten .NET Transactional DB

- Ref. Slides# 207 - 211.

### 118: Develop BasketRepository Class using Marten Library

- Created "IBasketRepository.cs" interface class
- Created skeleton rferencing interface "BasketRepository.cs"

### 119: Implement IBasketRepository Class using Marten IDocumentSession interface

- Ref. Slides# 212
- Added Nuget package ref. "Marten" to Basket API project.
- Implemented "BasketRepository" class to save data to document db.
- Implemented "BasketNotFoundException" class

### 120: Register and Configure Marten DocumentDB library into Program.cs asp.net DI

- Added Marten DocumentDB library support into Program.cs asp.net DI.

### 121: Setup PostgreSQL DB for Basket ms using Docker-compose file for Multi-container

- Updated Basket docker configuration in docker-componse and docker-componse-override.
- Updated "appsettings.json" to updated db connection string.

### 122: Run Docker-Compose on Visual Studio to setup PostgreSQL DB on Docker

- Run docker engine "Rancher" or "docker-desktop".
- check if new db is created and reflected in docker container.
- Connect to db and check if db is created with blank schema.

### 123: Develop Basket Features in CQRS Handler classes using BasketRepository

- Added support for repository in Basket API operations
- Repository added to Get, Store and Depete APIs
- Registered BasketRepository in program.cs

### 124: Connect Postgres DB from local Basket Microservices and send POST request

- Run docker Db
- Run application
- Send Store Basket request and see API working as expcted
- Update Rest API client
- Validate data stored in db

### 125: TEST Basket Microservices Endpoints connecting with Marten and Postgres DB

- Validate all operation working via rest client viz. store, get and delete.

### 126: Exception Handling in Basket Microservices

- Bug fix for delete operation
- Added support for generic exception and health checks

## Section 9: Baskeet Microservices apply Distributed Caching with Redis

### 127: Distributed Caching with Redis in Basket Microservices

- Implement Proxy Pattern, Decorator Pattern and Scrutor Library
- Implement Cache-aside Pattern / Cache invalidation
- Develop Cached BasketRepository and Decorate w/ Scrutor Library
- Setup Redis as a Distributed Cache using Docker-compose file for Multi-container docker environment
- Ref. slide# 215 - 217

### 128: Cache-aside Pattern in Microservices / Cache Invalidation

- Ref. slide# 218 - 222

### 129: Proxy Pattern, Decorator Pattern and Scrutor Library

- Ref. slide# 223 - 226

### 130: Develop CachedBasketRepository with Proxy Pattern, Decorator Pattern and Scrutor

- Ref. slide# 227 - 226
- Added new Class under Basket API / Data, ref "CachedBasketRepository".
- Implemented proxy and decorator pattern.

### 131: Develop CachedBasketRepository with Proxy Pattern, Decorator Pattern and Scrutor

- Implemented Cache logic in Cached Basked Repository class. For Get, Store and Delete operation.
- Added new package to support implementation - Microsoft.Extensions.Caching.StackExchangeRedis.

### 132: Register Decorated CachedBasketRepository and StackExchangeRedis with Scrutor

- Added new package "Scrutor" to decorate "CachedBasketRepository" for "IBasketRepository".
- Added redis support in pipeline.

### 133: ECommerce Microservices Deployment Strategy

- Ref. slide# 228 - 229

### 134: Setup Redis as a Distributed Cache using Docker-compose file for Multi-container

- Updated Docker-Compose and Docker-Compose-override files to support redis

### 135: Run Docker-Compose on Visual Studio to setup Redis Distributed Cache on Docker

- Run application with "Docker-Compose" as start up project.
- After running check Redis image is available in docker.
- Connect Redis using below commands

```pwsh
redis-cli
ping
key set key key-name-value
key get key key-name-value
key *
```

### 136: Configure docker-compose launch settings - Not open browser for microservices

- Right click on Docker-compose, Basket API and Catalog API.
- From Property tab, Set Launch Action = Do nothing.
- Valudate change in each project launchsettings.json file.

### 137: Connect Redis Cache from local Basket Microservices and send GET request

- Put break-point in get, store and delete and run application locally.
- Check keys are getting set, store and deleted successfully in debug mode.

### 138: Health Check for Basket Microservices with PostgresDB and Redis Cache

- Implemented health check in Basket microservice.
- Register health check for Redis and configured middleweare in https request pipeline.
- Run application and hit /health end point in local development env. and see whether service, postgres db and redis health checks are available in response.

### 139: Containerize Basket.API Microservices with Docker

- Containerize Basket.API Microservices from visual studio.
- Right click project -> add -> docker support -> Lunix and overwrite file.

### 140: Orchestrate Basket.API Microservices with Docker-compose file

- Updated Docker-Compose and Docker-Compose-override files to support running Basket API from docker

### 141: TEST - Docker-compose Basket.API microservices with PostgresDB and Redis

- Run docker compose up and validate application running inside the docker.
- Updated necessary settings and configuration and rest client.

## Section 10: Microservices synchronous communication with gRPC (8 min)

### 142: Microservices Communication Types: Synchronous or Asynchronous Communication

- Ref. slide# 233 - 235

### 143: Microservices Synchronous Communications and Best Practices

- Ref. slide# 236

### 144: gRPC: High Performance Remote Procedure Calls

- Ref. slide# 237 - 238

### 145: How gRPC works ?

- Ref. slide# 239

### 146: gRPC Usage in Microservices Communication

- Ref. slide# 240

## Section 11: Discount.gRPC Microservices for other Microservices gRPC communication (1 hr 28 min)

### Objective

- Build a Highly Performant inter-service gRPC Communication with Discount and Basket Microservice
- Exposing Grpc Services with creating Protobuf messages
- SQLite database connection and containerization
- Entity Framework Core ORM - SQLite Data Provider and Migrations to simplify data access and ensure high performance

### 147: Introduction - Discount.Grpc Microservices for Microservices Grpc Communication

- Ref. slide# 243 - 246

### 148: Create Asp.Net Grpc for Discount Microservices in Microservices Solution

- Added new folder "Discount" and created new project using template grpc.
- Run application and validate via postman if possible.

### 149: Domain Analysis of Discount Microservices: Models, UCs, Rest Apis, Databases

- Ref. slide# 249 - 252

### 150 : Technical Analysis of Discount Microservices: Architectures, Patterns, Libraries

- Ref. slide# 256 - 259

### 151: Develop Discount.API Microservices Creating Domain Entities

- Created new folder and added new model class called Coupon.

### 152: Develop discount.proto ProtoBuf file for Exposing Crud Services in Discount Grpc

- Created new proto file - Discount.proto and added operation and message details.

### 153: Generate Proto Service Class from Discount proto File in Discount Grpc service

- Changed property of.proto files as Build Action = Server Only and grpc sub class = server only.

### 154: Develop DiscountService class to Implement Grpc Proto Service Methods

- created new Discount.cs service class under service folder.
- overrride available CRUD methods.

### 155: Configure DiscountGrpc Service to Request Pipeline in Program.cs and Invoke Grpc

- Updated program.cs to configure discount service in pipeline.

### 156: Entity Framework Core and SQLite Database Connection in Discount Microservices

- Added new section for db connection string in appsettings.json.
- Added code in program.cs to fetch db connection string in popeline.
- Added new folder "Data" and added "DiscountContext" class.

### 157: Create SQLite Database using Entity Framework Core Tools in Discount service

- Added below packages to the solution

  ```xml
    <!-- Below are mandatory -->
    <PackageReference Include="Microsoft.EntityFrameworkCore.Sqlite" Version="9.0.3" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="9.0.3">
    <!-- Below are optional -->

  ```

- Execute following EF migration commands (in running in terminal) from csproj folder.

  ```pwsh
  dotnet add package Microsoft.EntityFrameworkCore.Design
  dotnet ef migrations add InitialCreate
  dotnet ef database update
  ```

- Execure following EF migration commands, executing from Visual Studio IDE -> Package Manager Console

  ```pwsh
  Install-Package Microsoft.EntityFrameworkCore.Tools
  Add-Migration InitialCreate
  Update-Database
  ```

### 158: Seed and Auto-Migrate SQLite Database using Entity Framework Core in Discount

- Create db and seed / fill data when application is started and db is not yet created.
- Added code in DiscountContext.cs as new method OnModelCreating to seed data on app is started (when no db is available)
- Added new static Extensions class under "data" folder.
- Updated Program.cs class where code added to apply migration in start up and also register the db context.

### 159: TEST - Seed and Auto-Migrate SQLite Database using Entity Framework Core

- Run application and see if new db is created.
- Check initial data is added on application startup.
- Check 2 tables are created in SQLLite Db.
- To view db, use VS Code SQLLite viewer extension

### 160: Develop DiscountService class to Implement Grpc Proto Service Methods

- Ref. slide# 261
- Implemented "GetDiscount" method in DiscountService class.
- Developed Discount.Grps.Client application to call Grpc service via Client.

### 161: Develop CreateDiscount in DiscountService class to Implement CRUD Grpc Proto

- Implemented "CreateDiscount" method in DiscountService class.

### 162: Develop UpdateDiscount in DiscountService class to Implement CRUD Grpc Proto

- Implemented "UpdateDiscount" method in DiscountService class.

### 163: Develop DeleteDiscount in DiscountService class to Implement CRUD Grpc Proto

- Implemented "DeleteDiscount" method in DiscountService class.

### 164: Containerize Discount.Grpc microservices with Docker

- Ref. slide# 262
- Create dockerfile for discount.grpc file using visual studio right click option.

### 165: Orchestrate Discount.Grpc microservices with Docker-compose file

- Ref. slide# 262
- Updated docker-compose and docker-compose-pverride files to suppor application running from docker env.

### 166: TEST - Docker-compose Discount.Grpc microservices with SQLite

- Validate end to end flow running application from docker env.
- Validate grpc calls using client created.

## Section 12: Consuming Discount.gRPC service from Basket Microservice when adding cart item (35 min)

- Consume Discount Grpc Service From Basket Microservice
- When Adding Cart Item into Shopping Cart To Calculate Final Price
- Integration of gRPC Client and Service Registration
- Consume Discount Service
- Re-Containerization

### 167: Introduction - Consuming Discount Grpc Service From Basket Microservice

- Ref. slide # 265 to 268

### 168: Consuming Discount Grpc Service From Basket Microservice When Adding Cart Item

- To consumer Discount.Grpc service in Basket API. Added Connected Service reference.
- Right click on Connected Service, select manage connected service.
- Click on + / add Service reference (open api, grpc, wcf web service etc.)
- Here locate and select .ptoro file from discount.grpc service.
- Select grpc type as client consumer.
- After adding of reference, check .csproj have added required class ref. and service ref. as well
- Check proto folder is created.
- Build solution and resolve if any error.

### 169: Consuming Discount Grpc Service From Basket API Microservice When Adding Cart -2

- Refactored, StoreBasketCommandHandler - "Handle" method.
- Created new method "DeductDiscount" for adding discount implementation for cart item.

### 170: Register Discount Grpc Client and Discount Grpc Service into the Basket.API

- Refactored Program.cs for better readability and maintainability. Added various region.
- Registered grpc client in request pipeline.
- Added required configuration in app.settings

### 171: Test and Run Discount Grpc and Basket Microservice

- In visual studio, new profile created at solution - right click - property level to run Basket and Discount servie together.
- Run docker infra
- Run Basket and discount service locally. Select profile that have configuration for running both the services togather.
- Check Grpc client get request works correctly
- Call Basket POST and then GET /username operation to test flow end to end.

### 172: Add Grpc DiscountUrl Configuration in Basket.API image configuration on Docker

- Updated docker-compose-override file, added end point of discount service in docker env. in basket api configuration.

### 173-174: Test on Docker environment - Basket.API communicate with Discount.Grpc in Docker

- Added code in Basket micro service to by pass server cert validation for https and allow traffic from any cert.
- Validateed end to end test case.
- Run services in docker env.
- Validate discount grpc service via grpc client in docker env.
- Validate basket api post and get operation in docker env.

## Section 13: Ordering Microservices with DDD, CQRS and Clean Architecture (58 min)

- Apply DDD, CQRS and Clean Architecture Patterns and Best Practices
- Implement Design Principles: SOLID, KISS, YAGNI, SoC, DIP
- Develop Clean Architecture Layers: Domain, Application, Infrasturcture and API
- CQRS with MediatR library to implement the Command and Command Handlers

### 175: Introduction - Ordering Microservices with DDD, CQRS and Clean Architecture

- Ref. slides - 269 - 274

### 176: Create Asp.Net Web Api for Ordering.API Microservice in Microservices Solution

- Create "Order" folder for Order API
- Create new ASP.net empty project template
- Configure proper path for micro service
- Setup project structure and configurations

### 177: Domain Analysis of Ordering Microservices: Models, UCs, Rest Apis, Databases

- Ref. slide # 275 - 279

### 178: Technical Analysis of Ordering Microservices: Architectures, Patterns, Libraries

- Ref. slide # 280 - 290

### 179: SOLID, KISS, YAGNI, SoC, DIP - Common Principles

- Ref. slide # 291 - 293

### 180: Apply DDD, CQRS and Clean Architecture patterns in Ordering microservice

- Ref. slide # 294

### 181: Domain Driven Design - DDD

- Ref. slide # 295 - 298

### 182: Clean Architecture

- Ref. slide # 302 - 306

### 183: Clean Architecture with Domain Driven Design(DDD)

- Ref. slide# 307 - 309

### 184: Code Structure on DDD and Clean Architecture Layers in Ordering Microservices

- Ref. slide # 310 - 311

### 185: Create Clean Architecture Layers: Domain, Application, Infrastructure and API

- Ref. slide # 308
- Created new empty Class Library project, name Order.Domain, Order.Application and Order.Infrastructure.

### 186: Adding Project References Between Clean Architecture Layers

- Ref. slide # 308
- In Order.Application - add project reference of Order.Domain and Building blocks.
- Order.Infrastructure - add project reference of Order.Application
- Order.Api - add project reference of Order.Application and Order.Infrastructure

### 187: Adding Dependency Injections Between Clean Architecture Layers

- Ref. slide # 308
- Created extension class to register service i.e. inject dependencies in each microservice except domain service.
- Implemented "DependencyInjection.cs" and associated methods in Application, Infra and API microservice.
- Added and registered reference of each service in pipeline of order.api service pipeline.

## Section 14: Ordering.Domain layer with Tactical Domain-driven design patterns (1 hr 20 min)

- Entities, Value Objects, Aggregates, Aggregate Roots Patterns
- The Domain Entity Pattern
- Develop Strongly typed IDs for Order Entities
- Anemic-domain model vs Rich-domain model Entities in DDD
- Domain Events in DDD and Domain vs Integration Events

### 188: Tactical Domain-Driven Design: Entities, Value Objects, Aggregates, Agg. Roots

- Ref. slide # 312 - 321

### 189: Develop DDD Abstractions (Entity, Aggregate, DomainEvent) in Ordering.Domain

- Ref. slide # 321
- Implemented Order.Domain project.
- Added reference of MediatR nuget for sending event notification
- Added and implemented interface - IEntity, IDomainEvents, IAggegrates
- Added and implemented base abstract class - Entity and Aggegrates

### 190: Domain Modeling with Tactical DDD for Ordering Microservices

- Ref. slide # 322 - 324

### 191: Develop Domain Modeling with DDD for Ordering Microservices

- Ref. slide # 322
- Implemented domain.model - required classes.
- Created folder "Abstractions" and added required models and interfaces - Entity, Aggegrates and Domain Event
- Created folder "Models" and added required models - Customer, Order, Orderitems and Product
- Created folder "ValueObjects" and added required models - Address and payment
- Created folder "Enum" and added required enums - PaymentStatus

### 192: Primitive Obsession and Strongly typed IDs in DDD

- Ref. slide # 325 - 326
- Removed common data type variables to Strongly Type variable in Order and OrderItem classes.

### 193: Develop Strongly typed IDs for Order Entities

- Created new ValueObjects - CustomerId, ProductId, OrderName, OrderItemId
- Refactored code under model to use strong type models - customer, order, orderitems and product.

### 194: Anemic-domain vs Rich-domain Model Entities Entities in DDD

- Ref. slide # 327 - 331

### 195: Develop DDD Rich-domain model Entity for Order Entities in Order.Domain Layer

- Enhanced DDD rich domain model entities in Customer and Customer Id class
- Introduced new exceptions type
- Updated Global include with newly introduced exception type.

### 196: Develop ValueObjects (Address, Payment) DDD Rich-domain model Entity

- Enhanced ValueObject entities / members with constructor and enhaced Of method.

### 197: Develop DDD Rich-domain model for Order Entities in Order.Domain Layer

- For reach domain model for Entities and Value Object following pattern will be used
  - Entities > Create() as Static Method
  - ValueObjects > Of() as Static Method
- Added create() for Order and Product class in model object

### 198: Domain Events in DDD and Domain vs Integration Events

- Ref. slide # 332 - 335

### 199: Develop Order Created and Updated Domain Event in Ordering Microservices

- Created "Event" folder with event record type - OrderCreatedEvent and OrderUpdatedEvent

## Section 15: Ordering.Infrastructure layer with EF.Core code first and SQL Server (2 hr 13 min)

- EF Core 8 Features, Code First Approach, Migrations and SQL Server
- EF Core DBContext Object for Storing Entities
- Mapping DDD Objects to EF Entities
- Order Entity Configurations w/ ComplexTypes
- Auto Migrate and Seed EF Core Entities to SQL Server DB

### 200: Develop Ordering.Infrastructure Layer with EF Core Code First Approach

- Ref. slide # 336 - 340

### 201: EF Core 8 Features, Code First Approach, Migrations and SQL Server Connection

- Ref. slide # 341 - 343

### 202: Steps of EF Core Developments for Ordering.Infrastructure

- Ref. slide # 344 - 356

### 203: Install EF Core Nuget Packages in Ordering.Infrastructure

- Ref. slide # 352
- Added  below nuget references to the Order.Infrastructure project

  ```pwsh
  Microsoft.EntityFrameworkCore.Tools
  Microsoft.EntityFrameworkCore.SqlServer
  ```

### 204: Develop EF Core DBContext Object for Storing Entities in Ordering.Infrastructure

- Ref. slide # 352
- Created folder "Data" and added class ApplicationDbContext

### 205: Mapping DDD Objects to EF Entities - Develop EF Core Entity Configurations

- Ref. slide # 352
- Created new folder under "Data\Configurations" and implemented Customer and Product EF configurations.

### 206: EF Core 8 Relations and DDD ValueObject Mapping with ComplexType and ComplexProp

- Ref. slide # 357 - 358

### 207: Mapping DDD Objects to EF Entities - Develop Order Entity Configurations

- Ref. slide # 352
- Implemented EF Core Entity Configuration for Order.Infra for complex types and complex properties
- Implemented EF Core Entity Configuration class - Customer, Order, OrderItems, Product

### 208: EF Core SQL Server Connection String in appsettings.json file

- Ref. slide # 353
- Added SQL Server Db connection string in order.api - appsettings.json.

### 209: Register EF Core DbContext in Asp.Net DependencyInjection Tool for SQL Server

- Ref. slide # 353
- Added code in Order.Infea for registerring EF Core DbContext in Asp.Net DependencyInjection Tool for SQL Server.
- Refacrored code and added common namespace in Global using namespace.

### 210-211: Create EF Core Migrations for ApplicationDbContext in Ordering.Infrastructure

- Ref. slide # 354, 359 - 363
- Set Order.API as start up project in order to apply EF.Core migration script correctly.
- Run following command from Visual Studio, under package manager window - select project = Order.Infrastructure

    ```pwsh
    Add-Migration InitialCreate -OutputDir Data/Migrations -Project Order.Infrastructure -StartupProject Order.API
    Update-Database
    ```

- Aleternately, run below command if running from terminal / VS code

  ```pwsh
  dotnet tool install --global dotnet-ef
  dotnet add package Microsoft.EntityFrameworkCore.Design
  dotnet ef migrations add InitialCreate
  dotnet ef database update
  ```

- Fixed error and issues observed in OrderId, OrderItemId, OrderName in Value Object.
- Fixed error and issues observed in Order and OrderItem configurations.
- Created migration folder and migration class by executing command.

### 212: Setup SQL Server DB using Docker-compose file for Multi-container Docker Env

- Updated Docker-compose file to spin up SQL Server in docker env.

### 213: Run Docker-Compose on Visual Studio to setup SQL Server DB on Docker

- Run docker-compose from VS and pull required docker images and run SQL container.

### 214: Apply EF Core Migrations to SQL Server DB with Update-Database Command

- Ref. slide # 366
- Execute "Update-Database" command to create Order Db

### 215: Auto Migrate EF Core Entities to SQL Server when Application Startup w/ Coding

- Ref. slide # 367
- Updated Program.cs and added steps to configured and see initial data sets.

### 216: Seed SQL Server OrderDb using EF Core when Application Startup with Coding

- Ref. slide # 367
- In Order.Infra project created new folder "Extensions" and implemented "DatabaseExtensions.cs" and "InitialData.cs".

### 217: Seed Product and Orders in SQL Server OrderDb using EF Core when App Startup

- Ref. slide # 367.
- Implemented "SeedProductAsync, SeedOrderAndItemsAsync" in DatabaseExtensions.cs.
- Implemented "public static IEnumerable Products, IEnumerable Order" in "InitialData.cs".

### 218: Run Order Microservices to Migrate and Seed OrderDb in SQL Server using EF Core

- Ref. slide # 367.
- Run docker compose and run all containers
- Run Order.API
- Validate initial data is inserted or not on 1st execution

### 219: EF Core Interceptors: SaveChangesInterceptor for Auditing Entities

- Ref. slide # 367 - 371

### 220: Develop SaveChangesInterceptor to Auditing Entities for Order Entities

- Ref. slide # 371
- Added new folder "Interceptors" and implemented AuditEntityInterceptor
- Registered AuditEntityInterceptor class in request pipeline.

### 221: Run&Test Order Microservices for Audit with EF Save Changes Interceptor

- Delete docker SQL Db
- Run docker compose
- Run application Order.API
- Validate db is created with initial value and also now audit columns are getting updated correctly in the application.

### 222: Dispatch Domain Events w/ EF Core SaveChangesInterceptor

- Ref. slide # 372 - 374

### 223: Develop DispatchDomainEventsInterceptor to Trigger Domain Event Handlers

- Ref. slide # 374
- Added new Interceptor class in Order.Infra project, called - DispatchDomainEventInterceptor
- Implemented override SavingChanges to raise domain events
- Refactored "Order.Infrastructure" --> "DependencyInjection" to add service scope for DispatchDomainEventInterceptor
- Refactored "Order.Application" --> "DependencyInjection" to register MediatR in request pipeline.

### 224: Run&Test Order Microservices for Dispatch DomainEvents with EF Save Changes

- Run docker compose and make sure docker sql is up
- delete old Order Db
- add breakpoint into Order.Infra - "Task DispatchDomainEvents(DbContext? context)" method and observe events are getting publish when order is created.

## Section 16: Ordering.Application layer with CQRS & MediatR (1 hr 49 min)

- Develop Orders CRUD OrderCommand and Handler
- Develop IApplicationDbContext for injection EFCore DB Context object
- Develop MediatR Pipeline Behaviours (Validation, Logging)
- Develop Domain Event Handlers with MediatR INotificationHandler
- Develop Order Queries with CQRS and MediatR

### 225: Develop Ordering.Application Layer with CQRS and MediatR implement the Command

- Ref. slide # 376 - 380

### 226: CQRS (Command Query Responsibility Segregation) Pattern in Ordering microservice

- Ref. slide # 381 - 380

### 227: Event Sourcing Pattern

- Ref. slide # 386 - 387

### 228: CQRS with Event Sourcing Pattern

- Ref. slide # 389

### 229: Eventual Consistency Principle

- Ref. slide # 390 - 391

### 230: Analysis of Ordering Microservice Application Layer

- Ref. slide # 392 - 396

### 231: Implement CQRS Command and Command Handler Patterns with MediatR

- Ref. slide # 397 - 403

### 232: Develop Ordering.Application Folder Structure for CQRS

- Ref. slide # 394
- In Order.Application Project created below skeleton for implementation and added new GlobalUsing.cs class

  ```xml
    <ItemGroup>
      <Folder Include="Data\" />
      <Folder Include="Dtos\" />
      <Folder Include="Orders\Commands\" />
      <Folder Include="Orders\EventHandlers\" />
      <Folder Include="Orders\Queries\" />
    </ItemGroup>
  ```

### 233: Develop Dto Classes for Orders in Ordering.Application Layer

- Ref. slide # 394
- Implemented Dtos - Order, OrderItem Address and Payment.

### 234: Develop Orders CreateOrderCommand and Handler in Ordering.Application Layer

- Ref. slide # 399 and 396.
- Added new folder under \orders\commands\createorder.
- Implemented new classes - CreateOrderCommand and CreateOrderHandler.

### 235: Develop IApplicationDbContext for injection EFCore DB Context object in Ordering

- Ref. slide # 399
- Added "Microsoft.EntityFrameworkCore" nuget reference on Order.Application project.
- Added implementation for IApplicationDbContext in Order.Application project.
- Refactored "Order.Infrastructure" classes - DependencyInjection and ApplicationDbContext to support IApplicationDbContext.

### 236: Develop Orders CreateOrderCommandHandler using IApplicationDbContext in Ordering

Chngaes done in Order.Application:

- Added Microsoft.EntityFrameworkCore nuget reference to be used in App db context
- Added new interface IApplicationDbContext
- Implemented CreateOrderHandler - Handle method
- Moved common namespace to global using

Changes done in Order.Infra:

- Refactored ApplicationDbContext to add support for IApplicationDbContext
- Added scope for IApplicationDbContext in DependencyInjection class

### 237: Develop Orders UpdateOrderCommand and Handler using IApplicationDbContext

- Ref. slide # 399

Chngaes done in Order.Application:

- Added UodateCommand and UpdateCommandHandle class implementation
- Added OrderNotFoundException in Exception folder
- Refactored namespaces and moved to global usings

### 238: Develop Orders DeleteOrderCommand and Handler using IApplicationDbContext

- Ref. slide # 399

Chngaes done in Order.Application:

- Added DeleteOrderCommand and DeleteCommandHandle class implementation

### 239: Develop MediatR Pipeline Behaviours (Validation, Logging) in Ordering.App

- Ref. slide # 402 - 405
- Added Validation and Logging behaviour using MediatR in dependency injection extension class in Order.Application.

### 240: Develop Domain Event Handlers with MediatR INotificationHandler in Ordering.App

- Ref. slide # 405 - 407

### 241: Develop Domain Event Handlers with MediatR INotificationHandler in Ordering.App

- added logging in OrderCreatedEventHandler and OrderUpdatedEventHandler classes

### 242: Develop Order Queries with CQRS and MediatR in Ordering.Application Layer

- Ref. slide # 399
- Added new folder "Queries" under "Orders" and implemented GetOrdersByNameQuery and OrderUpdatedEventHandler classes.

### 243: Develop Extention method for ProjectToOrderDto use in GetOrders Methods

- Implemented "OrderMappingExtensions" class.
- Refactored "GetOrdersByNameHandler" to use "OrderMappingExtensions" for mapping.

### 244: Develop GetOrdersByCustomer Queries w/ CQRS and MediatR in Ordering.Application

- Ref. slide # 399
- Implemente GetOrdersByCustomerQuery and GetOrdersByCustomerHandler classes.

### 245: Develop Pagination Class for Query GetOrders using CQRS and MediatR

- Ref. slide # 408
- Implemented "Pagination" classes in BuildingBlocks project.

### 246: Develop GetOrders Query apply Pagination using CQRS and MediatR in Ordering.App

- Ref. slide # 408
- Implemented "GetOrdersQuery" and "GetOrdersQueryHandler" classes.

## Section 17: Ordering.API layer exposing minimal API endpoint with Carter and REPR pattern (1 hr 29 min)

Objectives:

- Implement REPR Pattern for CQRS and MediatR Request LifeCycle
- Developing Order CRUD Endpoints for REST APIs in Ordering.API Layer
- Developing Get Order Endpoints for REST APIs in Ordering.API Layer
- Cross-Cutting Concerns Custom Exception Handler
- Health Checks for Ordering Microservices with EF.Core and SQL Server
- Testing Ordering.API Endpoints with CQRS and Clean Architecture

### 247: Develop Ordering.API Layer with Exposing Minimal REST APIs w/ Carter

- Ref. slide # 409 - 414

### 248: Analysis the Ordering.API layer in Clean Architecture

- Ref. slide # 415 - 419

### 249: Program.cs and Dependency Injection class in Ordering.API Layer

- Added nuget package "Carter" to Order.API project.

### 250: Developing Order Endpoints for REST APIs in Ordering.API Layer

- Ref. slide # 414, 418
- Created new folder "Endpoints"
- Added required classes for Order CRUD operations - CreateOrderEndpoint, UpdateOrderEndpoint, DeleteOrderEndpoint, GetOrdersEndpoint, GetOrderByNameEndpoint, GetOrderByCustomerEndpoint.

### 251: Developing CreateOrder Endpoint for REST APIs in Ordering.API Layer

- Ref. slide # 414, 420
- Implemented CreateOrderEndpoint class.

### 252: Developing UpdateOrder Endpoint for REST APIs in Ordering.API Layer

- Implemented UpdateOrderEndpoint class.

### 253: Developing DeleteOrder Endpoint for REST APIs in Ordering.API Layer

- Implemented DeleteOrderEndpoint class.

### 254: Developing GetOrdersByName Endpoint for REST APIs in Ordering.API Layer

- Implemented GetOrdersByNameEndpoint class.

### 255: Developing GetOrdersByCustomer Endpoint for REST APIs in Ordering.API Layer

- Implemented GetOrdersByCustomerEndpoint class.

### 256: Developing GetOrders Endpoint w/ Pagination for REST APIs in Ordering.API Layer

- Implemented GetOrdersEndpoint class.

### 257: Testing Ordering.API Endpoints with CQRS and Clean Architecture Layers

- Ref. slide # 421
- Setup required breakpoints in Order.API project before running application.
- Run docker compose to spin up SQL Server and run Order.API project locally connecting to SQL Server in docker.

### 258: Test Create Order Endpoint with CQRS and Clean Architecture Layers in Ordering

- Send POST request to create order endpoint using Postman or Rest Client.

### 259: Test Update Order Endpoint with CQRS and Clean Architecture Layers in Ordering

- Send PUT request to update order endpoint using Postman or Rest Client.

### 260: Test Get Order Endpoints with CQRS and Clean Architecture Layers in Ordering

- Send GET request to get orders, get orders w/ pagination, get order by name, get order by customer endpoints using Postman or Rest Client.

### 261: Test Delete Order Endpoint with CQRS and Clean Architecture Layers in Ordering

- Send DELETE request to delete order endpoint using Postman or Rest Client.

### 262: Cross-Cutting Concerns Custom Exception Handler in Ordering Microservice

- Refactored Order.API project - DependencyInjection to add custom exception handler.

### 263: Health Checks for Ordering Microservices with EF.Core and SQL Server

- Ref. slide # 422 - 423
- Added health check for Order.API in Program.cs file.
- Test endpoint /health to validate health check for Order.API and SQL Server.
- Test delete order when order is not available, it should return - order not found exception in formatted response.

## Section 18: Microservices async communication w/ RabbitMQ & MassTransit for checkout order (3 hr 2 min)

Objectives:

- Checkout Order use cases Between Basket-Ordering Microservices
- Using RabbitMQ Publish/Subscribe Topic Exchange Model
- Using MassTransit for abstraction over RabbitMQ Message-Broker
- Publishing BasketCheckout event queue from Basket microservices
- Subscribing event from Ordering microservices
- Create RabbitMQ BuildingBlocks.Messaging library

### 264: Introduction - Microservices Async Communication w/ RabbitMQ & MassTransit

- Ref. slide # 424 - 430

### 265: Microservices Asynchronous Communication

- Ref. slide # 431 - 434

### 266: Benefits of Asynchronous Communication

- Ref. slide # 435

### 267: Challenges of Asynchronous Communication

- Ref. slide # 436

### 268: Fan-Out Publish/Subscribe Messaging Pattern

- Ref. slide # 437

### 269: Event-Driven Microservices Architecture

- Missing slide

### 270: What is RabbitMQ and Main Components of RabbitMQ (Producer, Queue, Consumer..)

- Ref. slide # 440 - 441

### 271: RabbitMQ Exchange Types: Direct, Fanout, Topic, and Headers

- Ref. slide # 442 - 444

### 272: Domain Analysis of Async Communication between Basket and Ordering Microservices

- Ref. slide # 445 - 450

### 273: Technical Analysis of Async Communication between Basket and Ordering ms

- Ref. slide # 451 - 458

### 274: Steps of Developing Async Communication between Basket and Ordering Microservice

- Ref. slide # 459

### 275: Create BuildingBlocks.Messaging Shared Class Library for Common Async connection

- Ref. slide # 455, 457
- Under BuildingBlocks folder, created new class library project called "BuildingBlock.Messaging".

### 276: Develop BasketCheckout Event in BuildingBlocks.Messaging Shared Class Library

- Ref. slide # 459
- Created new folder "Events" and added implementation of IntegrationEvent and BasketCheckoutEvent class.

### 277: Develop MassTransit Extention Methods to Register RabbitMQ connection into DI

- Ref. slide # 459
- Added new folder "MassTransit" and implemented MassTransitExtension class.
- Added required nuget references to BuildingBlocks.Messaging project.

  ```xml
  <PackageReference Include="MassTransit" Version="8.0.0" />
  <PackageReference Include="MassTransit.RabbitMQ" Version="8.0.0" />
  ```

- Added Extension class for MassTransit.
- Added message broker configuration in Basket.API appsettings.json file.

### 278: Develop MassTransit Extention Methods to Register RabbitMQ connection into DI -2

- Refactored MassTransitExtension class to add RabbitMQ configuration in request pipeline.

### 279: Publish BasketCheckout Event from Basket Microservices

- Ref. slide # 459 - 461
- Implement Step# 2 - Basket.API to Publish BasketCheckout Event
- Added project reference of BuildingBlocks.Messaging in Basket.API project.
- Register masstransit configuration in Basket.API project request pipeline.

### 280: Develop BasketCheckout Feature Folder to Expose POST Endpoint and Publish Event

Changes done in Basket.API project:

- Ref. slide # 459
- Created new folders \basket\CheckOutBasket and \Dtos
- Added and implemented classes - BasketCheckOutDto and CheckOutBasketEndpoint
- Added CheckOutBasketHandler class structure.

### 281: Develop Basket Checkout Handler Method to Publish event to RabbitMQ-MassTransit

- Ref. slide # 461 - 462
- Implemented CheckoutBasketCommandHandler class to publish BasketCheckout event to RabbitMQ using MassTransit.

### 282: Dual-write Problem and Outbox Pattern

- Ref. slide # 463 - 470

### 283: Ordering Microservices to Subscribe-Consume BasketCheckout event from RabbitMQ

- Ref. slide # 471 474
- Implement Step# 3 - Ordering Microservices to Subscribe and Consume BasketCheckout Event
- Added project reference of BuildingBlocks.Messaging in Order.Application project.

### 284: Register MassTransit RabbitMQ packages into Ordering.Application DI

Changes done in Order.Application project:

- Updated appsettings.json file to add RabbitMQ configuration.
- Added AddMessageBroker method in DependencyInjection class to register MassTransit RabbitMQ configuration in request pipeline.

Changes done in Order.API project:

- Updated program.cs file to register MassTransit RabbitMQ configuration in request pipeline.

### 285: OrderCreated Integration Event: How Domain Event leads to Integration Event

- Ref. slide # 472 - 476

### 286: Develop Basket Checkout Event Consumer integration event handler class

- Ref. slide # 474
- Moved OrderCreatedEventHandler and OrderUpdatedEventHandler classes to Domain Event Handlers folder.
- New Integration event handler class - BasketCheckoutEventHandler created under EventHandlers folder.

### 287: Develop Basket Checkout Event Consumer integration event handler class - 2

- Implemented BasketCheckOutEventHandler class
- corrected BasketCheckoutEvent class

### 288: Saga Pattern for Distributed Transactions

- ref. slide # 478 - 480

### 289: Publish OrderCreated Integration event for Order Fulfillment microservices

- Implement Step# 4 - BONUS- Publish OrderCreated Integration event for order fulfillment microservices and implement SAGA Pattern
- Ref. slide # 474, 476
- Implemented OrderCreatedEventHandler class to publish OrderCreated integration event to RabbitMQ using MassTransit.

### 290: Aspnet Feature Management Develop Feature Flag for OrderCreated Event

- Ref. slide # 481
- Nuget reference added to BuildingBlocks project

  ```xml
  <PackageReference Include="Microsoft.FeatureManagement.AspNetCore" Version="3.0.0" />
  ```

- Added appsettings.json configuration for feature management in Order.API project.
- Order.Application project updated to register Feature Management in request pipeline.
- Implemented feature flag in OrderCreatedEventHandler class to control publishing of OrderCreated integration event.

### 291: Setup RabbitMQ for Async Communication using Docker-compose file

- Ref. slide # 482 - 484, 486
- Updated docker-compose file to spin up RabbitMQ in docker env.

### 292: Run Docker-Compose on Visual Studio to setup RabbitMQ on Docker

- Updated docker-compose and docker-compose.override file to spin up RabbitMQ container.
- Updated API appsettings.json file to add RabbitMQ configuration.
- Run docker-compose from Visual Studio to spin up RabbitMQ container.
- Check RabbitMQ management console at http://localhost:15670/ with default user and password as "guest".

### 293: TEST- Publish BasketCheckout Event in Basket.API Microservices

- Ref. slide # 483
- Set up Startup projects in solution to run as Basket.API and Discount.Grpc microservices.
- Make new Purchase in Basket API using Postman or Rest Client (POST /basket). Check new basket item is added for use in "basket" postgres db.
- Make Checkout Basket in Basket API using Postman or Rest Client (POST /basket/checkout). Check domain events are generated and publish in rabbitmq.

### 294: TEST- Subscribe/Consume BasketCheckout Event in Ordering.API Microservices

- Set solution properties to rul all 3 microservices - Basket.API, Discount.Grpc and Order.API.
- Make sure RabbitMQ is up and running.
- Make new Purchase in Basket API using Postman or Rest Client (POST /basket). Check new basket item is added for use in "basket" postgres db.
- Make Checkout Basket in Basket API using Postman or Rest Client (POST /basket/checkout). Check domain events are generated and publish in rabbitmq.
- Check Order.API is subscribed to BasketCheckout event and OrderCreated integration event is published in RabbitMQ.
- Check OrderCreated integration event is consumed by OrderCreatedEventHandler and order is created in SQL Server database.
- Potential bug fixes.

### 295: TEST- Set OrderFullfilment feature = false. Re-Test Publish - Subscribe/Consume

- Set OrderFullfilment feature = false in appsettings.json file of Order.API project.
- Re-test end to end flow of BasketCheckout event.

### 296: Containerize and Configure Basket, Ordering and RabbitMQ Containers

- Ref. slide # 485 - 487
- Updated docker-compose file to override docker environment for Basket.API for RabbitMQ connection.

### 297: Containerize and Orchestrate Ordering microservices with Docker & Docker-Compose

- Ref. slide # 485 - 487
- Updated docker-compose file to to containerize and orchestrate Ordering microservices with Docker & Docker-Compose.

### 298: TEST- Docker-Compose Microservices - Publish/Subscribe BasketCheckout Event

- Ref. slide # 486 - 488
- Set docker as startup project in solution.
- Run docker-compose from Visual Studio to spin up all containers.
- Fixed and updated docker-compose and settings files to run entire application in docker environment.
- Updated and corrected all docker configuration needed for application to run in docker environment.
- Verify all microservices are running and accessible.

## Section 19: Build API GW with Yarp reverse proxy applying GW routing pattern (1 hr 26 min)

Objective:

- Gateway Routing, API Gateway Pattern, BFF Backend for Frontend
- YARP as a Reverse Proxy
- Implement API Gateway using YARP Reverse Proxy in YarpApiGateway
- Rate Limiting to YARP Reverse Proxy as an API Gateway
- Containerize and Orchestrate YarpApiGateway as an API Gateway in Docker-Compose

### 299-307: Introduction - API Gateways with Yarp Reverse Proxy, concept and understanding

- Ref. slide # 489 - 521

### 308: Create YarpApiGateway Microservices into ECommerce Solution

- Create new ASP.Net Empty project template to create YarpApiGateway microservice.
- Configured launch settings to run YarpApiGateway microservice.

### 309: Develop Yarp Reverse Proxy in YarpApiGateway Microservices

- Added nuget reference of Yarp.ReverseProxy in YarpApiGateway project.
- Configured Yarp.ReverseProxy in Program.cs file.
- Added Yarp.ReverseProxy configuration in appsettings.json file.
- Validate product catalog service is accessible via YarpApiGateway. 
- Using https port 5054

### 310 - 312: Implement API Gateway using Yarp Reverse Proxy in YarpApiGateway Microservices

- Added configuration for Basket, Catalog and Ordering microservices in YarpApiGateway appsettings.json file.
- Validated end to end GET operation flow for Basket, Catalog and Ordering microservices via YarpApiGateway.

### 313: Rate Limiting to Yarp Reverse Proxy as an API Gateway in YarpApiGateway

- Implemented Rate Limiting in YarpApiGateway project and also added configuration in appsettings.json file.
- Validate rate limiting is working correctly by sending multiple requests to YarpApiGateway.
- Test: send more than 5 request multiple time in 10 seconds, it should return 503 Service Unavailable error.

### 314 - 317: Containerize and Orchestrate YarpApiGateway as an API Gateway in Docker-Compose

- Updated docker-compose file to spin up YarpApiGateway container.
- Updated docker-compose.override file to override docker environment for YarpApiGateway,
- Updated appsettings.json file to add YarpApiGateway configuration.
- Added appsettings.local.json file to run YarpApiGateway in local environment.
- Run end to end flow of YarpApiGateway with Basket, Catalog and Ordering microservices in docker environment.

## Section 20: Building shopping web client application with Refit HttpClientFactory library (2 hr 45 min)

**Objectives**:

- ASP.NET Web Application Razor Pages with Bootstrap 4 Theme
- ASP.NET Core Razor Tools — View Components, Partial Views, Tag Helpers, Model Bindings and Validations, Razor Sections
- Consume YarpApiGateway Endpoints using Refit Library with Generated HttpClientFactory
- Refit HttpClientFactory Library: The automatic type-safe REST library
- Develop Index/Cart/Product/Detail/Checkout/Order HTML and C#

### 318 - 321: Introduction - Shopping Web Client Application with Refit HttpClientFactory library

- Ref. slide # 527 - 546

### 322: Developing Shopping Web Application Microservices

- Create new ASP.Net Web Application project with Razor Pages template.

### 323 - 325: Create models for web application to consume api via yarp reverse proxy

- Create new folder "Models" and add required models - Basket, Catalog, Order
- Implemented Basket, Catalog and Order models in Models folder.

### 326: Develop Service Classes for consume YarpApiGateway

- Ref. slide # 549, 541
- Implemented ICatalogService interface.

### 327: Refit HttpClientFactory Library: The automatic type-safe REST library

- Understand Refit library and how it works with HttpClientFactory to consume REST APIs.

## Section 21: End of Course & Bonus lectures

## 999: Troubleshooting

- Command to see git logs in nice one line manner

    ```cmd
    git log --graph --format='%C(yellow)%h%Creset  %s %Cgreen(%cr) %C(bold blue)<%an>%Creset'
    git log --pretty=format:"%C(yellow)%h%Creset - %C(cyan)%an%Creset, %Cgreen%ar%Creset : %s" --graph    
    ```

- Command to assign alias to gitlog command to use as shortcut

  ```pwsh
  git config --global alias.elog "log --pretty=format:'%C(yellow)%h%Creset - %C(cyan)%an%Creset, %Cgreen%ar%Creset : %s' --graph"
  # to see pretty log next time
  git elog 
  ```

- was facing issue for running docker compose in VS 2022, unable to run docker compose.

  - At chapter #63, when running docker compose from visual studio 2022 and installed with Rancher, ref. [Git Hub: VS code - Rancher desktop](https://github.com/rancher-sandbox/rancher-desktop/issues/3474). Copied settings.json file at location "*C:\Users\CONMVU\AppData\Roaming\Docker*".

  - After that added following block to docker-compose.yml file.

      ```yaml
      catalog.api:
          image: ${DOCKER_REGISTRY-}catalogapi
          build:
          context: .
          dockerfile: Services/Catalog/Catalog.API/
      ```

  - After performing these twicks, able to run docker componse and able to spin the containers from visual studio 2022.

- Following command used to resolve Git remote push issue:

    ```pwsh
    git config --local user.name "<git user name>"
    git config --local user.email "<git associated email>"
    git branch -M main
    git remote add origin https://github.com/pandyamehul/eShop.MicroService.net8.git
    git push -u origin main

    git remote -v
    # origin  git@github.com:pandyamehul/eShop.MicroService.net8.git (fetch)
    # origin  git@github.com:pandyamehul/eShop.MicroService.net8.git (push)


    git config --get remote.origin.url
    # git@github.com:pandyamehul/eShop.MicroService.net8.git

    # Finally following steps worked to sync repo to remote from locally.
    git remote rm origin
    git remote -v
    git remote add origin https://github.com/pandyamehul/eShop.MicroService.net8.git
    git push -u origin main
    ```

### 02: Install EF Tools

Executed below commands to install EF Core tools

```pwsh
dotnet tool install --global dotnet-ef
dotnet tool restore
```

### 03: Ref. Git repo

```txt
  https://github.com/aspnetrun/run-aspnetcore-microservices/blob/master/
```
